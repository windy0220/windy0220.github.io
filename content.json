{"meta":{"title":"大马的个人网站","subtitle":"一个技术博客","description":null,"author":"大马","url":"http://bigma.cc"},"pages":[],"posts":[{"title":"群晖docker更新homeassistant","slug":"群晖docker更新homeassistant","date":"2022-03-09T16:20:26.000Z","updated":"2023-09-06T14:03:24.665Z","comments":true,"path":"2022/03/10/群晖docker更新homeassistant/","link":"","permalink":"http://bigma.cc/2022/03/10/群晖docker更新homeassistant/","excerpt":"docker版的homeassistant是最容易更新的，不用输入命令，点几下就搞定。","text":"docker版的homeassistant是最容易更新的，不用输入命令，点几下就搞定。 打开docker 在注册表中输入homeassistant 选择 homeassistant/home-assistant 右键-下载此映像 选择 latest 下载完成后，在日志中可看到 Add image from docker.io/homeassistant/home-assistant:latest 选择容器关闭 homeassistant 容器 右键-操作-(重置)清除-是 不用担心你的数据都在，如果实在不放心，可以把镜像导出备份一下 再打开 更新成功","categories":[],"tags":[]},{"title":"开启openClash之后，github的clone报错的问题","slug":"开启openClash之后，github的clone报错的问题","date":"2022-03-08T16:18:20.000Z","updated":"2023-09-06T14:03:24.665Z","comments":true,"path":"2022/03/09/开启openClash之后，github的clone报错的问题/","link":"","permalink":"http://bigma.cc/2022/03/09/开启openClash之后，github的clone报错的问题/","excerpt":"","text":"今天在clone github 上的代码的时候发现报错了。如下图 1234567Cloning into 'blog'...kex_exchange_identification: Connection closed by remote hostConnection closed by xxx.xxx.xxx.xxx port 22fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 在尝试关掉openClash之后发现，可以正常了，看来是代理的问题。 经过搜索，发现只要在规则里增加一条，便可以解决问题。 我的是在路由中使用的 openClash 操作方法具体如下： 全局设置-规则设置-打开自定义规则 在rules: 中增加一条 - DST-PORT,22,DIRECT 拉到最下放 点击保存配置，应用配置 等待重启完成之后便可以正常clone了。","categories":[],"tags":[{"name":"openclash","slug":"openclash","permalink":"http://bigma.cc/tags/openclash/"},{"name":"github","slug":"github","permalink":"http://bigma.cc/tags/github/"},{"name":"gitclone","slug":"gitclone","permalink":"http://bigma.cc/tags/gitclone/"},{"name":"失败","slug":"失败","permalink":"http://bigma.cc/tags/失败/"}]},{"title":"使用pixle1手机备份照片至google Photo","slug":"使用pixle1手机备份照片至google Photo","date":"2021-10-23T19:23:34.000Z","updated":"2023-09-06T15:38:00.513Z","comments":true,"path":"2021/10/24/使用pixle1手机备份照片至google Photo/","link":"","permalink":"http://bigma.cc/2021/10/24/使用pixle1手机备份照片至google Photo/","excerpt":"","text":"iPhone 通过Pixle1 无限容量特权 备份照片到谷歌相册 Google Photo一直在用google photo ，各种的图片分类和整理真的很方便，还会不定期的推送，它自动合成的视频和一些动图，虽然国内也有一刻相册，ios的相册也有了类似的功能，但这些跟googlePhoto比起来还是略有不足 今年2021年6月1号开始，谷歌相册开始不免费了，再备份就会占用15GB的存储空间，我也一直在找替代方案，尝试一些其他的相册服务之后，实在是不够完美，无意间发现 pixle 1 还可以无限容量的备份，就来了思路。 所需设备：主力机，Pixle1, 群晖。 软件： Syncthing 首先从闲鱼150收了一个二手的Pixle1 , 没有声音，略有烧屏，不过便宜能用就好。 到手升级到了安卓10 ，居然有声音了，心想赚了，重启后又没有了，网上搜索了一下才知道，这个是当时的通病，不过无所谓了。 看到相册这里，的确说明可以免费无限备份 群晖安装 SyncthingSyncthing 介绍请看官网这里就不多做介绍了。 https://docs.syncthing.net/index.html 先在套件中心新增一个套件来源 名称随意这里填写：imnks 位置填写：https://spk.imnks.com 这里的地址仅供参考。要是无法添加可以再换一个。 然后就是搜索 Syncthing 点击安装。安装成功之后等待启动。 启动完成之后，我们在浏览器中输入 http://192.168.2.42:8384/# 这里的地址换成你的NAS地址 端口号是 8384 先在左侧新增文件夹，下图是我配置好的 这里的文件夹路径可以在群晖的文件管理中右键-属性获得 这里我是通过手机上的 Moments app 备份至群晖的，这个Moments/Mobile文件夹下 就是根据你备份设备的名称自动建立了。因为我之前已经有了大量照片，新的同步方案只用于新的照片，我把我的手机改了下名称，这样再通过 Moments 同步到群晖 就会生成一个新的文件夹。 复制这里的 所在位置，填入 Syncthing 的文件夹路径中 第二个tab签是 要共享的设备 我这里已经有了 Pixel 版本控制不用启用，忽略模式这里要填上 @eaDir 这个目录是群晖的全局搜索建立的索引目录，如果不排查也会同步到 远程设备上，这个我们是不需要的。 高级这里我们选择仅发送即可，其他不用修改了。 在pixle1上安装 Syncthing 安装之后，先通过 右上角的 + 来添加设备。 这里我们打开 群晖上的 Syncthing Web端 扫码添加 扫码添加后就可以在手机端的设备tab签下看到了。 然后切换到 文件夹 tab 添加一个要接收文件的文件夹，这里要注意的是，文件夹的路径要选到 DCIM 目录下，这个是相册目录，谷歌相册自动就识别了，有文件后就自动上传。目录种类这里 选择仅接收，这样等我们手机的存储占满后可以使用谷歌相册的释放空间功能释放本地空间，也不会影响NAS上的文件。 至此已配置完成。之后手机上通过Moments 备份至 NAS后，Pixel1便会自动备份了，且是无限容量哦。 对了，记得关闭主力设备上的谷歌相册备份功能。 后记：ios的 livephoto 照片通过pixle1备份到google photo 后发现是一个 照片加一个视频，跟ios 直接备份的1张动态图片有出入，我通过查询发现，google 是通过备份设备来判断的，pixle1不会生成 live photo的照片，所以备份到 google photot 就是分开的，这个暂时无解。","categories":[],"tags":[{"name":"googlePhoto","slug":"googlePhoto","permalink":"http://bigma.cc/tags/googlePhoto/"},{"name":"pixle","slug":"pixle","permalink":"http://bigma.cc/tags/pixle/"},{"name":"备份照片","slug":"备份照片","permalink":"http://bigma.cc/tags/备份照片/"}]},{"title":"阿里云OSS自动转换webP图片","slug":"阿里云OSS自动转换webP图片","date":"2021-06-07T09:39:56.000Z","updated":"2023-09-06T15:29:05.207Z","comments":true,"path":"2021/06/07/阿里云OSS自动转换webP图片/","link":"","permalink":"http://bigma.cc/2021/06/07/阿里云OSS自动转换webP图片/","excerpt":"","text":"WebP 图片格式是由 Google 基于 VP8 视频编码格式研发，其优势体现在其图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。 然而，由于较早版本的浏览器不支持 WebP 格式，因此现阶段还不应将全站图片转换为 WebP 格式。目前主流自适应 WebP 解决方案包括使用标签，浏览器端 js 检测替换以及 http header 识别等。部分 CDN 服务（又拍云，腾讯云等）也已经提供了自适应 WebP 图片转换功能。考虑到现有大量图片托管在阿里云 OSS 上，并通过CDN回源加速，在为了减少工作量，考虑采用 CDN 边缘脚本 + OSS 图片处理的方法实现类似功能。 但并不是所有的浏览器都支持这种图片格式，因此我们需要根据浏览器判断支持并返回正确的图片。我之前曾一直使用的又拍云是可以一键打开 WebP 自适应转换的，但阿里云这边并没有看到这样的选项，不过没关系，我们可以通过边缘脚本实现相同的功能。 OSS 添加图片 WebP 样式首先需要在 OSS Bucket 管理功能中添加自定义图片处理规则，并在访问设置中设置自定义分割符（例如设置为感叹号 ! ）。此时即可通过在 OSS 资源访问地址中追加样式尾缀（分隔符+规则名称，例如 !webp ）的方法对图片进行在线处理。 另外可以在访问设置中设置自定义标识符，直接通过样式输出图片。 CDN 设置边缘脚本实现自动跳转在 CDN 管理界面添加边缘脚本，根据 HTTP 相应头判断浏览器是否支持 WebP 图片格式，如果支持则 301 重定向至包含包含图片处理尾缀 “!webp” 的访问路径，注意尾缀应与规则名称一致。 12345m1 = and($http_accept, match_re($http_accept, '.*image\\/webp.*'))m2 = match_re($uri, '.+(.JPEG|.jpeg|.JPG|.jpg|.PNG|.png)$')if and(m1, m2) &#123; rewrite(concat($uri, '!webp'), 'enhance_redirect', 301)&#125; 设置完成后可在模拟环境下测试自适应重定向是否成功（Chrome浏览器中重定向，ie中无效），并可通过浏览器开发者模式检查图片是否为 WebP 格式。","categories":[],"tags":[{"name":"阿里云","slug":"阿里云","permalink":"http://bigma.cc/tags/阿里云/"},{"name":"OSS","slug":"OSS","permalink":"http://bigma.cc/tags/OSS/"},{"name":"webP","slug":"webP","permalink":"http://bigma.cc/tags/webP/"},{"name":"图片优化","slug":"图片优化","permalink":"http://bigma.cc/tags/图片优化/"}]},{"title":"阿里云OSS图片优化参数","slug":"阿里云OSS图片优化参数","date":"2021-06-07T06:16:23.000Z","updated":"2023-09-06T15:30:18.293Z","comments":true,"path":"2021/06/07/阿里云OSS图片优化参数/","link":"","permalink":"http://bigma.cc/2021/06/07/阿里云OSS图片优化参数/","excerpt":"","text":"您可以通过格式转换参数，转换存储在OSS内原图的格式。本文介绍对图片进行格式转换时所用到的参数及示例。 参数说明操作名称：format 参数说明如下： 取值范围 描述 jpg 将原图保存成JPG格式，如果原图是PNG、WebP、BMP等存在透明通道的格式，默认会把透明填充成白色。 png 将原图保存成PNG格式。 webp 将原图保存成WebP格式。 bmp 将原图保存成BMP格式。 gif 原图为GIF图片则继续保存为GIF格式；原图不是GIF图片，则按原图格式保存。 tiff 将原图保存成TIFF格式。 注意事项 图片处理包含缩放操作时，建议将格式转换参数放到处理参数的最后。 例如image/resize,w_100/format,jpg 图片处理包含缩放和水印操作时，建议将格式转换参数添加在缩放参数之后。 例如image/reisze,w_100/format,jpg/watermark,... 示例本文示例使用的Bucket为杭州地域名为image-demo的Bucket，图片外网访问地址为： https://image-demo.oss-cn-hangzhou.aliyuncs.com/example.gif[![gif](/images/p139212.png)](http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/8448459951/p139212.png) 将原图转换为PNG格式 图片处理URL为：https://image-demo.oss-cn-hangzhou.aliyuncs.com/example.gif?x-oss-process=image/format,png[![png](/images/p139213.png)](http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/8448459951/p139213.png) 将原图转换成JPG格式，并支持渐进显示 需求及处理参数如下： 图片设置为渐进显示：interlace,1 图片转换为JPG格式：format,jpg 图片处理URL为：https://image-demo.oss-cn-hangzhou.aliyuncs.com/example.gif?x-oss-process=image/interlace,1/format,jpg 将原图缩放为宽200 px，并转换为WebP格式 需求及处理参数如下： 图片缩放为宽200 px：resize,w_200 图片转换为WebP格式：format,webp 图片处理URL为：https://image-demo.oss-cn-hangzhou.aliyuncs.com/example.gif?x-oss-process=image/resize,w_200/format,webp[![img](/images/p2559.webp)](http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/1548459951/p2559.webp?spm=a2c4g.11186623.2.12.48fc66a35FOLP9&amp;file=p2559.webp) 原文地址 https://help.aliyun.com/document_detail/44703.html?spm=a2c4g.11186623.6.752.665f7fd8tuPrz4","categories":[],"tags":[{"name":"阿里云","slug":"阿里云","permalink":"http://bigma.cc/tags/阿里云/"},{"name":"OSS","slug":"OSS","permalink":"http://bigma.cc/tags/OSS/"},{"name":"webP","slug":"webP","permalink":"http://bigma.cc/tags/webP/"},{"name":"图片优化","slug":"图片优化","permalink":"http://bigma.cc/tags/图片优化/"},{"name":"优化参数","slug":"优化参数","permalink":"http://bigma.cc/tags/优化参数/"}]},{"title":"windows node版本管理工具nvm的安装和使用","slug":"node版本管理工具nvm的安装和使用","date":"2021-05-27T16:09:38.000Z","updated":"2023-09-06T14:03:24.663Z","comments":true,"path":"2021/05/28/node版本管理工具nvm的安装和使用/","link":"","permalink":"http://bigma.cc/2021/05/28/node版本管理工具nvm的安装和使用/","excerpt":"在实际的前端开发工作中，我们经常要维护一些老项目使用的是较旧版本的node和npm，新的项目又要使用比较新的node和npm，这时候就要祭出node版本工具了，上次说过 Linux上的node版本工具n，这次就来看看windows上的node版本管理工具nvm如何安装和使用。","text":"在实际的前端开发工作中，我们经常要维护一些老项目使用的是较旧版本的node和npm，新的项目又要使用比较新的node和npm，这时候就要祭出node版本工具了，上次说过 Linux上的node版本工具n，这次就来看看windows上的node版本管理工具nvm如何安装和使用。 下载安装官方给出了绿色版和安装版，这里推荐安装版，更方便快捷，省区了配置环境变量的麻烦。 下载地址 https://github.com/coreybutler/nvm-windows/releases 下载 nvm-setup.zip 即可。 下载完成解压安装即可。 这里要注意的是有两个路径提示，第一个是nvm的安装路径，第二个是nodeJs的安装路径。如果你的nodeJs安装在默认路径下。一路下一步即可安装成功。 使用nvm安装nodeJs安装 14.17.0 1nvm install 14.17.0 注意这里的版本号，需要真是存在才可以。可以去 https://nodejs.org/zh-cn/download/releases/ 查询需要的版本 如果遇到下载失败，也没有关系，我们可以到阿里的镜像网站下载对应的安装包，解压到nvm的路径里 例如我们需要 14.17.0 的版本 https://npm.taobao.org/mirrors/node/v14.17.0/ 找到 node-v14.17.0-win-x64.7z 下载解压至 C:\\Users\\【这里一般是你的用户名】\\AppData\\Roaming\\nvm\\v14.17.0 即可。 如果遇到安装后，node可以使用 npm 用不了也可以使用此方法。 切换node版本1nvm use 14.17.0 即可切换。 如果切换后使用 node -v 命令发现版本没有切换。可以把原来安装的nodeJs目录改掉 如我原来的nodeJs安装目录是 C:\\Program Files\\nodejs 改为 C:\\Program Files\\nodejsx 即可成功 显示安装的版本123nvm list* 14.17.0 (Currently using 64-bit executable) 8.17.0 带* 号的则为当前版本 链接汇总nvm 下载地址 https://github.com/coreybutler/nvm-windows/releases nodeJs官方版本库 https://nodejs.org/zh-cn/download/releases/ 阿里镜像源 https://npm.taobao.org/mirrors/node/","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://bigma.cc/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://bigma.cc/tags/npm/"},{"name":"nvm","slug":"nvm","permalink":"http://bigma.cc/tags/nvm/"},{"name":"windows","slug":"windows","permalink":"http://bigma.cc/tags/windows/"},{"name":"版本管理","slug":"版本管理","permalink":"http://bigma.cc/tags/版本管理/"}]},{"title":"Centos 安装 NodeJs PM2 守护NUXT","slug":"centOsInstallNodeJs","date":"2020-06-07T15:28:48.000Z","updated":"2023-09-06T14:03:24.661Z","comments":true,"path":"2020/06/07/centOsInstallNodeJs/","link":"","permalink":"http://bigma.cc/2020/06/07/centOsInstallNodeJs/","excerpt":"","text":"获取下载链接进入以下页面，获取 Linux Binaries (x64) 的链接https://nodejs.org/en/download/ 若需要其他版本请访问 https://nodejs.org/dist/ 以下安装步骤以 node-v12.18.0-linux-x64 为例，其他版本替换相应路径即可。 下载wget https://nodejs.org/dist/v12.18.0/node-v12.18.0-linux-x64.tar.xz 解压xz -d node-v12.18.0-linux-x64.tar.xztar -xf node-v12.18.0-linux-x64.tar 部署这里注意node解压的路径 以 ~ 目录为例ln -s ~/node-v12.18.0-linux-x64/bin/node /usr/bin/nodeln -s ~/node-v12.18.0-linux-x64/bin/npm /usr/bin/npmln -s ~/node-v12.18.0-linux-x64/bin/npm /usr/bin/npx 测试node -vnpmnpx 安装pm2npm i -g pm2 运行1pm2 start npm --name &quot;package.json中的应用名称&quot; -- run start pm2 常用命令 说明 命令 启动进程/应用 pm2 start bin/www 或 pm2 start app.js 重命名进程/应用 pm2 start app.js –name wb123 添加进程/应用 watch pm2 start bin/www –watch 结束进程/应用 pm2 stop www 结束所有进程/应用 pm2 stop all 删除进程/应用 pm2 delete www 删除所有进程/应用 pm2 delete all 列出所有进程/应用 pm2 list 查看某个进程/应用具体情况 pm2 describe www 查看进程/应用的资源消耗情况 pm2 monit 查看pm2的日志 pm2 logs 若要查看某个进程/应用的日志,使用 pm2 logs www 重新启动进程/应用 pm2 restart www 重新启动所有进程/应用 pm2 restart all nginx 反向代理设置12345678server &#123; listen 80; server_name 域名1 域名2; location / &#123; root /data/wwwroot/路径; # 前端文件目录 proxy_pass http://127.0.0.1:3000; &#125;&#125; pm2 开机启动12345678# 启动项目pm2 start npm --name \"package.json中的应用名称\" -- run start# 保存当前进程状态pm2 save# 生成开机自启动服务pm2 startup# 启用开机自启systemctl enable pm2-root 错误 -bash: pm2: command not found替换 node-v12.18.0-linux-x64 为你的node 版本号 1ln -s /root/node-v12.18.0-linux-x64/lib/node_modules/pm2/bin/pm2 /usr/local/bin 执行 npm i失败安装node-sass时会出现，Permissions Errors 使用二进制安装的Node 会有权限问题。1chown -R root:root node-v8.10.0-linux-x64","categories":[],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://bigma.cc/tags/Centos/"},{"name":"NodeJs","slug":"NodeJs","permalink":"http://bigma.cc/tags/NodeJs/"}]},{"title":"navicat 恢复数据后部分表丢失","slug":"new_navcat_restore_lost_table","date":"2020-05-30T16:43:29.000Z","updated":"2023-09-06T14:03:24.663Z","comments":true,"path":"2020/05/31/new_navcat_restore_lost_table/","link":"","permalink":"http://bigma.cc/2020/05/31/new_navcat_restore_lost_table/","excerpt":"","text":"发现问题使用 navicat 恢复备份后发现部分表丢失查看错误日志发现 创建表失败12[Err] 1067 - Invalid default value for &apos;*******&apos;[Err] Failed to create Table: ******* 解决方案搜索之后发现是因为升级到 mysql 5.7 之后默认值不兼容的问题。解决办法就是修改 sql_mode 解决windows 环境下进入到 mysql 的 bin 目录下shift加鼠标右键 选择在此处打开PowerShell 窗口 1.\\mysql -hlocalhost -P3306 -uroot -p123123 注意这里在PowerShell下要使用 .\\mysql 不是直接使用 mysql 输入 show variables like &#39;sql_mode&#39;; 查看当前的 sql_mode 设置 Variable_name Value sql_mode ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 如果结果中包含 NO_ZERO_IN_DATE, NO_ZERO_DATE则需要修改 在命令行中执行1set session sql_mode=‘ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION’; 这只是临时会话有效。需要修改配置文件。 尝试使用1set sql_mode=‘ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION’; 也没有效果。 这里通过修改 配置文件 实现 · windows my.ini · linux my.cnf 在配置文件[mysqld]中加上 注意要加在[mysqld]中1sql_mode=&apos;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos; 重启服务器，再次导入navicat备份，全部成功 附 sql_mode常用值 name desc ONLY_FULL_GROUP_BY 对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中 NO_AUTO_VALUE_ON_ZERO 该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。 STRICT_TRANS_TABLES 在该模式下，如果一个值不能插入到一个事务中，则中断当前的操作，对非事务表不做限制 NO_ZERO_IN_DATE 在严格模式下，不允许日期和月份为零 NO_ZERO_DATE 设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告 ERROR_FOR_DIVISION_BY_ZERO 在insert或update过程中，如果数据被零除，则产生错误而非警告。如果未给出该模式，那么数据被零除时Mysql返回NULL NO_AUTO_CREATE_USER 禁止GRANT创建密码为空的用户 NO_ENGINE_SUBSTITUTION 如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常 PIPES_AS_CONCAT 将”&#124;&#124;”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样是，也和字符串的拼接函数Concat想类似 ANSI_QUOTES 启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符","categories":[],"tags":[]},{"title":"使用wordpress RESTfull API 制作网站的内容管理系统","slug":"wordpress-api","date":"2020-05-04T06:29:03.000Z","updated":"2023-09-06T14:03:24.664Z","comments":true,"path":"2020/05/04/wordpress-api/","link":"","permalink":"http://bigma.cc/2020/05/04/wordpress-api/","excerpt":"","text":"获取分类12http://ex.wordpress.com/wp-json/wp/v2/categories/分类idhttp://ex.wordpress.com/wp-json/wp/v2/categories?parent=父级分类id 获取文章列表1234567891011121314151617# 默认10篇http://ex.wordpress.com/wp-json/wp/v2/posts# 指定分类categories=分类id# 带特色图片和作者信息_embed=true# 页码page=2# 设置每页返回数量(1~100)per_page=2# 偏移offset=1 返回说明12345# 集合中的记录总数X-WP-Total# 包含所有可用记录的总页数X-WP-TotalPages 获取文章1http://ex.wordpress.com/wp-json/wp/v2/posts/文章id 根据标签获取文章1http://ex.wordpress.com/wp-json/wp/v2/posts?tags=标签id filter1234567891011# 指定标签的文章http://ex.wordpress.com/wp-json/wp/v2/posts?filter[tag]=library# 指定日期的文章http://ex.wordpress.com/wp-json/wp/v2/posts?filter[year]=2016&amp;filter[monthnum]=03# 指定作者的文章http://ex.wordpress.com/wp-json/wp/v2/posts?filter[author_name]=jinyun# 随机文章http://ex.wordpress.com/wp-json/wp/v2/posts?filter[orderby]=rand 标签12http://ex.wordpress.com/wp-json/wp/v2/tagshttp://ex.wordpress.com/wp-json/wp/v2/tags/3 媒体12http://ex.wordpress.com/wp-json/wp/v2/mediahttp://ex.wordpress.com/wp-json/wp/v2/media/3 页面12http://ex.wordpress.com/wp-json/wp/v2/pageshttp://ex.wordpress.com/wp-json/wp/v2/pages/3 类型12http://ex.wordpress.com/wp-json/wp/v2/typeshttp://ex.wordpress.com/wp-json/wp/v2/types/post 评论12http://ex.wordpress.com/wp-json/wp/v2/commentshttp://ex.wordpress.com/wp-json/wp/v2/comments/2 用户12http://ex.wordpress.com/wp-json/wp/v2/usershttp://ex.wordpress.com/wp-json/wp/v2/users/2 必备插件WP-China-Yes安装后可以解除更新和商店的封锁，可以正常更新和安装插件作者站点 https://www.ibadboy.net/archives/3204.htmlgit地址 https://github.com/sunxiyuan/wp-china-yes点击 clone or download 按钮，点击 Download ZIP 既可下载在wordpress 后台的安装插件处 上传安装。 高级自定义字段可以给文章扩展自定义字段，可根据条件显示不同的字段 Simple Custom Post Order &amp;&amp; Post Types Order文章和栏目拖拽排序，这两个插件必须都安装，才可以实现拖拽排序 Admin Menu Editor自定义后台的菜单目录 WP文件管理器可以管理网站的目录 REST API Helper可以让rest api 显示出 封面图片，作者，类别，和自定义字段 OSS Upload上传图片到阿里云oss forminator强大的自定义表单插件 forminator强大的自定义表单插件 Contact Form 7表单插件，可支持 REST APIhttp://www.yourdomain.com[你的域名]/wp-json/contact-form-7/v1/contact-forms/358[表单ID]/feedback 插件只支持发送到邮件，但可以通过 Flamingo 插件保存信息说明 https://contactform7.com/save-submitted-messages-with-flamingo/在额外的设置标签下添加 [the-email-field] 为配置中的字段1234skip_mail: onflamingo_email: &quot;[the-email-field]&quot;flamingo_name: &quot;[the-name-field]&quot;flamingo_subject: &quot;[the-subject-field]&quot; skip_mail: on 为跳过邮件发送启用插件后，可在目录中找到Flamingo 点击进入收件箱数据保存在 wp_postmeta 表中 aliyun-cdn-helper刷新阿里云的cdn服务https://github.com/0xJacky/aliyun-cdn-helper","categories":[],"tags":[]},{"title":"使用VSCode调试Nuxt.js","slug":"debug-nuxt","date":"2020-04-30T16:00:20.000Z","updated":"2023-09-06T14:03:24.661Z","comments":true,"path":"2020/05/01/debug-nuxt/","link":"","permalink":"http://bigma.cc/2020/05/01/debug-nuxt/","excerpt":"由于Nuxt是在服务端获取API接口数据的，所有无法在浏览器中直接调试。 下面介绍使用VSCode调试Nuxt.js的服务端接口","text":"由于Nuxt是在服务端获取API接口数据的，所有无法在浏览器中直接调试。 下面介绍使用VSCode调试Nuxt.js的服务端接口 点击 VSCode 侧栏上的 debug 工具，选择添加配置文件 添加如下内容 12345678910111213&#123; \"version\": \"0.2.0\", \"configurations\": [ &#123; \"type\": \"node\", \"request\": \"attach\", \"name\": \"调试nuxt\", \"processId\": \"$&#123;command:PickProcess&#125;\", \"port\": 9229 &#125; ]&#125; 然后运行 npm run dev 选择好配置文件后，点击签名的小三角开始调试，会弹出窗口提示选择node.js进程。选择nuxt 本地的调试进程就好。默认是3000的端口 之后就进入了调试状态。 在VSCode中打上响应的断点，然后刷新对应的页面，就可以愉快的debug了。","categories":[],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"http://bigma.cc/tags/VSCode/"},{"name":"debug","slug":"debug","permalink":"http://bigma.cc/tags/debug/"},{"name":"nuxt","slug":"nuxt","permalink":"http://bigma.cc/tags/nuxt/"}]},{"title":"go/beego 从入门到部署","slug":"about-go","date":"2020-04-24T16:57:02.000Z","updated":"2023-09-06T14:03:24.661Z","comments":true,"path":"2020/04/25/about-go/","link":"","permalink":"http://bigma.cc/2020/04/25/about-go/","excerpt":"","text":"go get 失败的问题使用七牛云的中国代理 https://goproxy.cn/12345678910$ go env -w GO111MODULE=on$ go env -w GOPROXY=https://goproxy.cn,direct# macOs$ export GO111MODULE=on$ export GOPROXY=https://goproxy.cn# windowsC:\\&gt; $env:GO111MODULE = &quot;on&quot;C:\\&gt; $env:GOPROXY = &quot;https://goproxy.cn&quot; 安装Gohttps://golang.google.cn/dl/ 12345# 查看版本号go version# 查看环境变量go env vscode 开发可以安装 go的插件 一个Demomain.go1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"你好\")&#125; 运行1go run main.go 基本语法变量定义123456789101112131415161718192021# 变量名称由数字、字母、下划线组成，首个字符不能为数字var 变量名称 类型 = 值 # 类型推导var 变量名称 := 值 # 一次声明多个变量var 变量名称,变量名称 类型 //类型一致var ( //类型不一致 变量名称 类型 变量名称 类型 变量名称 类型)# 短变量声明法 只能在函数内部使用，不是全局变量变量名称 := 值 # 短变量一次声明多个变量名称,变量名称,变量名称 := value1, value2, value3# 匿名变量 用来忽略某些值 ,如果一个函数返回两个值，但只需要一个值的时候可以使用匿名变量 _ 变量定义后必须使用，声明后不赋值则为空 常量1234567891011121314151617181920212223242526const pi = 3.14pi = 2 //error 常量不可改变// n1 n2 n3 n4 都是100const ( n1 = 100 n2 n3 n4)// iotaconst ( n1 = iota //0 n2 //1 n3 //2 n4 //3 _ //跳过 n5 //5)const ( n1, n2 = iota+1, iota+2 //1 2 n3, n4 // 3 4) go fmt fileName.go 可以格式化代码 数据类型123456// 1 int int8 int16 int32 int64var num int = 10// 类型转换 int8 转换成 int16var num1 int8 = 10int16(num1) 内置函数打印方法fmt 包1234ftm.Println(&quot;&quot;) //换行打印 fmt.Print(&quot;&quot;) //不换行打印 fmt.Printf(&quot;类型:%T, 值1:%v, 值2:%v&quot;, 变量1, 变量2, 变量3) // %v 原样输出；%d 10进制输出； %b 2进制输出；%o 8进制 %x 16进制 unsafe.Sizeof 可以查看不同长度的整型，在内存中的存储空间12var a int8 = 99fmt.Println(unsafe.Sizeof(a)) 安装beego 及 bee 工具123go get -u github.com/astaxie/beego$ go get -u github.com/beego/bee 创建一个API项目1bee api projectName 正在施工…","categories":[],"tags":[]},{"title":"常用linux命令","slug":"linux-command","date":"2020-04-22T15:07:07.000Z","updated":"2023-09-06T14:03:24.663Z","comments":true,"path":"2020/04/22/linux-command/","link":"","permalink":"http://bigma.cc/2020/04/22/linux-command/","excerpt":"","text":"tar压缩 解压缩12345# 压缩tar czvf filename.tar dirname# 解压缩tar zxvf filename.tar 指定用户或组 将目前目录下的所有文件与子目录的拥有者皆设为 www，群体的使用者 www:1chown -R www.www * iptables12345678# 查看 iptablesiptables -nvL# 添加规则 这里添加了一个 3306 端口iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT# 保存service iptables save mysql数据库12345678910# 登录数据库mysql -uroot -p# 创建一个用户create user username@'%' identified by 'password';# 授权grant all privileges on *.* to windy_db@'%' with grant option;# *.* 为所有权限， 也可以指定库和表 dbname.tablename# grant all privileges 为授权所有操作，也可单独指定 grant select,insert,update,delete,create,drop","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://bigma.cc/tags/linux/"},{"name":"command","slug":"command","permalink":"http://bigma.cc/tags/command/"},{"name":"常用","slug":"常用","permalink":"http://bigma.cc/tags/常用/"},{"name":"命令","slug":"命令","permalink":"http://bigma.cc/tags/命令/"}]},{"title":"centos更新node和npm版本","slug":"centos-update-npm-node","date":"2020-04-10T17:19:32.000Z","updated":"2023-09-06T14:03:24.661Z","comments":true,"path":"2020/04/11/centos-update-npm-node/","link":"","permalink":"http://bigma.cc/2020/04/11/centos-update-npm-node/","excerpt":"","text":"使用 n 工具 管理node 版本1npm install -g n 安装node 1234567n 版本号# 安装最新的稳定版本n stable# 安装最新版本n latest 列表所有安装的版本 1n list 切换版本 12345# 会显示一个可交互选择的列表n# 切换至指定版本n 版本号 删除版本 1n rm 版本号 错误处理如果npm -v报一下错误 1Segmentation fault 使用 n 5.10.1 安装一个低版本 然后 n list 列出所有按装的版本 n rm 12.16.1 删除错误的版本 n stable 安装最新的稳定版本 npm版本管理升级 1npm i -g npm 若升级后版本没有变化 1234567获取当前npm 路径 查看路径是否是最新的npm 路径npm config get prefix重新设置npm路径npm config set prefix /usr/local","categories":[],"tags":[{"name":"centos","slug":"centos","permalink":"http://bigma.cc/tags/centos/"},{"name":"node","slug":"node","permalink":"http://bigma.cc/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://bigma.cc/tags/npm/"},{"name":"update","slug":"update","permalink":"http://bigma.cc/tags/update/"},{"name":"更新","slug":"更新","permalink":"http://bigma.cc/tags/更新/"},{"name":"Segmentation fault","slug":"Segmentation-fault","permalink":"http://bigma.cc/tags/Segmentation-fault/"}]},{"title":"使用weinre在windows上调试ios页面","slug":"使用weinre在windows上调试ios页面","date":"2019-12-17T03:54:53.000Z","updated":"2023-09-06T14:03:24.664Z","comments":true,"path":"2019/12/17/使用weinre在windows上调试ios页面/","link":"","permalink":"http://bigma.cc/2019/12/17/使用weinre在windows上调试ios页面/","excerpt":"想调试ios页面却没有mac电脑，ios-webkit-debug-proxy 又有各种问题链接不上。可以试下 weinre！ 不挑系统，都能调试，只要在要调试的脚本中添加一段js就好。对于在线的页面也可以使用抓包工具注入js脚本调试。","text":"想调试ios页面却没有mac电脑，ios-webkit-debug-proxy 又有各种问题链接不上。可以试下 weinre！ 不挑系统，都能调试，只要在要调试的脚本中添加一段js就好。对于在线的页面也可以使用抓包工具注入js脚本调试。 安装1npm install weinre -g --registry=https://registry.npm.taobao.org 运行 1weinre --httpPort 8081 --boundHost -all- 然后使用浏览器打开 http://localhost:8081/ 可以看到 在需要调试的页面上插入一段js 1&lt;script src=\"http://换成你的ip:8081/target/target-script-min.js#anonymous\"&gt;&lt;/script&gt; 手机页面的本地调试 本地起一个服务器，使用xampp 或 phpStudy 或其他你顺手的都可以。 本地开热点，windows 10 自带，如果你是台式机可能需要一个无线网卡才行 配置本地host 执行本地的服务器，服务器也要配置相应的域名 手机连上热点就可以使用Host中配置的域名访问本地站点了。 tips: 可能需要关闭本地的防火墙能访问到 weinre 的脚本，或者把node.js添加到排除中，可以在手机上直接访问脚本试试。 调试点击 Access Points 下的 debug client user interface 在 Targets 中选中要调试的页面 就可以愉快的调试了，类似于 chrome 的控制台。","categories":[],"tags":[{"name":"debug","slug":"debug","permalink":"http://bigma.cc/tags/debug/"},{"name":"ios","slug":"ios","permalink":"http://bigma.cc/tags/ios/"},{"name":"windows","slug":"windows","permalink":"http://bigma.cc/tags/windows/"},{"name":"weinre","slug":"weinre","permalink":"http://bigma.cc/tags/weinre/"},{"name":"调试","slug":"调试","permalink":"http://bigma.cc/tags/调试/"}]},{"title":"js各种高度的获取","slug":"jsHeight","date":"2019-07-18T09:02:32.000Z","updated":"2023-09-06T14:03:24.662Z","comments":true,"path":"2019/07/18/jsHeight/","link":"","permalink":"http://bigma.cc/2019/07/18/jsHeight/","excerpt":"js各种高度的获取","text":"js各种高度的获取 距离父元素顶部的距离12345// jsele.offsetTop;// jq$('ele').offset().top; 网页被卷起来的高度123456// jsdocument.documentElement.scrollTop || document.body.scrollTopwindow.pageYOffset// jq$(window).scrollTop() 元素的高度/宽度12345// jsdocument.querySelector('.eleClass').clientHeight;// jq$('.eleClass').height(); 窗口的高度12//jswindow.innerHeight || document.documentElement.clientHeight getBoundingClientRect12345//元素顶部距窗口顶部的距离element.getBoundingClientRect().top //元素底部部距窗口顶部的距离element.getBoundingClientRect().bottom","categories":[],"tags":[{"name":"offsetTop","slug":"offsetTop","permalink":"http://bigma.cc/tags/offsetTop/"},{"name":"pageYOffset","slug":"pageYOffset","permalink":"http://bigma.cc/tags/pageYOffset/"},{"name":"clientHeight","slug":"clientHeight","permalink":"http://bigma.cc/tags/clientHeight/"},{"name":"getBoundingClientRect","slug":"getBoundingClientRect","permalink":"http://bigma.cc/tags/getBoundingClientRect/"}]},{"title":"hassio 折腾 未完工","slug":"hassio","date":"2019-04-09T16:25:15.000Z","updated":"2023-09-06T14:03:24.662Z","comments":true,"path":"2019/04/10/hassio/","link":"","permalink":"http://bigma.cc/2019/04/10/hassio/","excerpt":"","text":"树莓派安装 hass.io 折腾记下载烧录这是官方的下载地址 https://www.home-assistant.io/hassio/installation/ 一开始下的1.12版怎么也进不去系统，后来换了1.1版才可以。 https://github.com/home-assistant/hassos/releases/download/1.1/hassos_rpi3-64-1.1.img.gz 然后下载一个烧录工具etcher https://www.balena.io/etcher/ 把镜像烧到sd卡中 需要16G 以上的 TF 卡 官方推荐32G的卡 配置无限连接配置 wifi 需要单独准备一个U盘来存放wifi连接信息 https://github.com/home-assistant/hassos/blob/dev/Documentation/network.md uuid 的生成地址 https://www.uuidgenerator.net/ 在network文件夹内创建文件my-network 修改其中的 ssid为你的wifi psk 为你的wifi密码 1234567891011121314151617181920[connection]id=hassos-networkuuid=72111c67-4a5d-4d5c-925e-f8ee26efb3c3type=802-11-wireless[802-11-wireless]mode=infrastructuressid=MY_SSID[802-11-wireless-security]auth-alg=openkey-mgmt=wpa-pskpsk=MY_WLAN_SECRET_KEY[ipv4]method=auto[ipv6]addr-gen-mode=stable-privacymethod=auto 安装 HASSIO一定要给安装hassio的树莓派全程翻墙 启动后过一会访问hassio.loacl:8123会看到一个蓝色的房子让你等20分钟，如果你翻墙网速够好也就20分钟的事，要不然可能永远也不会好。 添加插件源Hass.io -&gt; ADD-ON STORE https://github.com/hassio-addons/repository 主要的插件 SSH server可以让你ssh连接hass.io 配置也比较简单 1234&#123; \"authorized_keys\": [], \"password\": \"youPassWord\"&#125; Configurator可以在页面上编辑hass.io的配置文件，配置文件是hass.io的核心内容，通过简单的配置在不用安装插件的情况下就可以接入大量智能设备 配置 123456789101112131415161718192021&#123; \"username\": \"yourUserName\", \"password\": \"yourPassWord\", \"ssl\": false, \"certfile\": \"fullchain.pem\", \"keyfile\": \"privkey.pem\", \"allowed_networks\": [ \"192.168.0.0/16\", \"172.30.0.0/16\" ], \"banned_ips\": [ \"8.8.8.8\" ], \"banlimit\": 0, \"ignore_pattern\": [ \"__pycache__\" ], \"dirsfirst\": false, \"enforce_basepath\": false, \"notify_service\": \"persistent_notification.create\"&#125; 你也可以使用winscp连接ssh直接编辑文件，但使用 Configurator 会帮你纠错 custom-uihttps://bbs.hassbian.com/thread-3975-1-4.html 开启MQTT12mqtt: password: mqttPassWord 默认值 Setting Value Port 1883 User homeassistant Websocket port 8080 接入homekit在 configuration 文件里添加 1homekit: 如果之前激活过，需要删掉config文件夹下的 .homekit.state 文件 然后重启 斐讯设备小米设备博联设备ESP8266ESP_Easy_0 192.168.4.1 烧录固件时把io0接到GND 不接RXD TXD 可运行 MQTT的配置 Devices -&gt; Send to Controller Tools -&gt; Advanced -&gt; 勾上 MQTT Retain Msg Controller -&gt; Edit -&gt; 填入MQTT 的 IP ，端口一般为1883, Controller User为homeassistant(hassio默认) 密码是在配置文件中配置的，Controller Subscribe 默认，Controller Publish 改第一个变量 如 /Lux/%tskname%/%valname% Enabled 勾上 然后到 hassio 的 configuration 文件中配置 1234567sensor 3: - platform: mqtt name: \"Lux\" # 随便起，但中文不行 state_topic: \"/Lux/2561/Lux\" # /你在esp8266 controller 中配置的/devices中的name/devices 中的Values 单位 qos: 0 retain: true unit_of_measurement: \"lux\" # 单位 Node RED添加插件源 https://github.com/notoriousbdg/hassio-addons 资料参考hass.io 官网 https://www.home-assistant.io hass.io 组件一览表 https://www.home-assistant.io/components/ HassBan论坛 https://bbs.hassbian.com/forum.php ESP EASY 官网 https://www.letscontrolit.com/ ESP EASY wiki https://www.letscontrolit.com/wiki/index.php/Main_Page 安可信官网 http://en.ai-thinker.com/ ESP8266文档 http://en.ai-thinker.com/esp8266/docs 软件下载安信可串口调试助手 http://en.ai-thinker.com/_media/tools/aithinker_serial_tool_v1.2.3.7z 物料列表树莓派3B+ 32G TF卡 ESP8266 芯片 ESP01 ESP8266 芯片 ESP V3 面包板 杜邦线 TTL 光敏传感器","categories":[],"tags":[{"name":"hassio","slug":"hassio","permalink":"http://bigma.cc/tags/hassio/"},{"name":"物联网","slug":"物联网","permalink":"http://bigma.cc/tags/物联网/"}]},{"title":"windows调试IOS页面工具","slug":"page","date":"2019-03-02T15:10:21.000Z","updated":"2023-09-06T14:03:24.663Z","comments":true,"path":"2019/03/02/page/","link":"","permalink":"http://bigma.cc/2019/03/02/page/","excerpt":"","text":"安装Scoop环境win10 命令行工具 Power Shell iex (new-object net.webclient).downloadstring(&#39;https://get.scoop.sh&#39;) 如果以上命令出错可能需要改变组策略 执行以下命令Set-ExecutionPolicy RemoteSigned -scope CurrentUser 安装 ios-webkit-debug-proxy项目git https://github.com/google/ios-webkit-debug-proxy 如果 ping github.com 超时去以下网址查询github.com 和 github.global.ssl.fastly.net 的IPhttps://www.ipaddress.com/ 然后在hosts里添加192.30.253.112 github.com151.101.185.194 github.global.ssl.fastly.net执行 ipconfig /flushdns 刷新缓存 scoop bucket add extrasscoop install ios-webkit-debug-proxy 启动代理ios_webkit_debug_proxy会提示Listing devices on :9221 ios_webkit_debug_proxy -f chrome-devtools://devtools/bundled/inspector.htmlListing devices on :9221 使用chrome 打开http://localhost:9222/","categories":[],"tags":[{"name":"debug","slug":"debug","permalink":"http://bigma.cc/tags/debug/"},{"name":"ios","slug":"ios","permalink":"http://bigma.cc/tags/ios/"}]},{"title":"iis导出导入站点的方法","slug":"iis导出导入站点","date":"2018-09-03T14:25:10.000Z","updated":"2023-09-06T14:03:24.662Z","comments":true,"path":"2018/09/03/iis导出导入站点/","link":"","permalink":"http://bigma.cc/2018/09/03/iis导出导入站点/","excerpt":"公司的前端开发需要配置很多的iis站点，还要配置站点的各种虚拟路径，要是换电脑就悲剧了。所以找到了，导出导入站点的办法，减少工作量。","text":"公司的前端开发需要配置很多的iis站点，还要配置站点的各种虚拟路径，要是换电脑就悲剧了。所以找到了，导出导入站点的办法，减少工作量。使用系统管理员运行cmd 应用池12# 导出处所有应用池%windir%\\system32\\inetsrv\\appcmd list apppool /config /xml &gt; c:\\apppools.xml 12# 导入处所有应用池%windir%\\system32\\inetsrv\\appcmd add apppool /in &lt; c:\\apppools.xml 这里要注意如果有重名的应用池就会导入失败，所以导入前要先删掉 默认的应用池 比如 DefaultAppPool 站点12# 导出处所有站点%windir%\\system32\\inetsrv\\appcmd list site /config /xml &gt; c:\\sites.xml 12# 导入处所有站点%windir%\\system32\\inetsrv\\appcmd add site /in &lt; c:\\sites.xml 同样要删掉重名的站点 比如 Default Website 单独导入导出1234567891011# 导出单独应用程序池:%windir%\\system32\\inetsrv\\appcmd list apppool “应用程序池名称” /config /xml &gt; c:\\myapppool.xml# 导入单独应用程序池:%windir%\\system32\\inetsrv\\appcmd add apppool /in &lt; c:\\myapppool.xml # 导出单独站点:%windir%\\system32\\inetsrv\\appcmd list site “站点名称” /config /xml &gt; c:\\mywebsite.xml # 导入单独站点:%windir%\\system32\\inetsrv\\appcmd add site /in &lt; c:\\mywebsite.xml","categories":[],"tags":[{"name":"iis","slug":"iis","permalink":"http://bigma.cc/tags/iis/"}]},{"title":"openwrt 下 dnsmasq 的配置","slug":"dnsmasq","date":"2018-08-22T14:55:15.000Z","updated":"2023-09-06T14:03:24.661Z","comments":true,"path":"2018/08/22/dnsmasq/","link":"","permalink":"http://bigma.cc/2018/08/22/dnsmasq/","excerpt":"dnsmasq 可以在局域网内 对网址映射到ip 类似于本地电脑的host","text":"dnsmasq 可以在局域网内 对网址映射到ip 类似于本地电脑的host 打开 openwrt 上dnsmasq配置文件1vi /etc/config/dhcp 在 config dnsmasq 下添加1list address &apos;clients1.google.com/clients2.google.com/203.79.253.17&apos; clients1.google.com/clients2.google.com为域名，可以设置多个，使用‘/’分隔，最后一段是ip 重启使之生效1/etc/init.d/dnsmasq restart","categories":[],"tags":[{"name":"openwrt","slug":"openwrt","permalink":"http://bigma.cc/tags/openwrt/"},{"name":"dnsmasq","slug":"dnsmasq","permalink":"http://bigma.cc/tags/dnsmasq/"}]},{"title":"@media 媒体查询分辨率收集及使用说明","slug":"media-媒体查询分辨率收集及使用说明","date":"2018-07-18T14:59:18.000Z","updated":"2023-09-06T14:03:24.663Z","comments":true,"path":"2018/07/18/media-媒体查询分辨率收集及使用说明/","link":"","permalink":"http://bigma.cc/2018/07/18/media-媒体查询分辨率收集及使用说明/","excerpt":"收集的一些响应式网页媒体查询的分辨率","text":"收集的一些响应式网页媒体查询的分辨率 苹果官网1234567891011121314151617181920@media only screen and (max-width: 1044px) &#123; #ac-globalnav &#123; min-width:320px &#125;&#125;@media only screen and (max-width: 1023px) &#123; #ac-gn-segmentbar &#123; min-width:320px &#125;&#125;@media only screen and (max-width: 767px) &#123; #ac-globalnav .ac-gn-searchresults-list &#123; padding:3px 30px 0 &#125;&#125;@media only screen and (max-width: 419px) &#123; #ac-globalnav .ac-gn-searchresults-list &#123; padding:4px 0 &#125;&#125; 微软官网123456789101112131415161718192021222324252627282930@media (min-width:1779px) &#123; html img.vp6 &#123; display:block; &#125;&#125;@media (min-width:1400px) and (max-width:1778px) &#123; html img.vp5 &#123; display:block; &#125;&#125;@media (min-width:1084px) and (max-width:1399px) &#123; html img.vp4 &#123; display:block; &#125;&#125;@media (min-width:768px) and (max-width:1083px) &#123; html img.vp3 &#123; display:block; &#125;&#125;@media (min-width:540px) and (max-width:767px) &#123; html img.vp2 &#123; display:block; &#125;&#125;@media (max-width:539px) &#123; html img.vp1 &#123; display:block; &#125;&#125; @media 使用说明设置meta1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"&gt; width = device-width：宽度等于当前设备的宽度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）加载兼容JSIE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果：1234&lt;!--[if lt IE 9]&gt;&lt;script src=\"//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js\"&gt;&lt;/script&gt;&lt;script src=\"//cdn.bootcss.com/respond.js/1.4.2/respond.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 设置IE渲染方式默认为Edge1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; 除了在@media 规则中使用外，媒体查询也可应用于HTML标签以将样式表的应用限于某个特定媒体。1&lt;link rel=\"stylesheet\" media=\"screen and (min-width: 900px)\" href=\"widescreen-styles.css\" /&gt; 基本语法123@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125; 媒体类型 mediatype all适用于所有设备。 print为了加载合适的文档到当前使用的可视窗口. 需要提前咨询 paged media（媒体屏幕尺寸）, 以满足个别设备网页尺寸不匹配等问题。 screen主要适用于彩色的电脑屏幕 speech解析speech这个合成器. 媒体查询包括四种逻辑运算符 and|not|only and (min-width: 700px) and (orientation: landscape) &#123; ... &#125;```1234- 逗号分隔(or)```@media (min-width: 700px), handheld and (orientation: landscape) &#123; ... &#125; not not 对整句查询起效 not all and (monochrome) &#123; ... &#125;```1234等价于```@media not (all and (monochrome)) &#123; ... &#125; 而不是 (not all) and (monochrome) &#123; ... &#125;```1234- only```@media only (min-width: 300px) &#123; ... &#125; 可用的其他参数 media feature width:浏览器可视宽度。 height:浏览器可视高度。 device-width:设备屏幕的宽度。 device-height:设备屏幕的高度。 orientation:检测设备目前处于横向还是纵向状态。 aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9) device-aspect-ratio:检测设备的宽度和高度的比例。 color:检测颜色的位数。 color-index:检查设备颜色索引表中的颜色，他的值不能是负数。 monochrome:检测单色楨缓冲区域中的每个像素的位数。 resolution:检测屏幕或打印机的分辨率。 grid：检测输出的设备是网格的还是位图设备。 常用的分辨率1234567891011/* 大屏幕 */@media (min-width: 1200px) &#123; ... &#125; /* 平板电脑和小屏电脑之间的分辨率 */@media (min-width: 768px) and (max-width: 979px) &#123; ... &#125; /* 横向放置的手机和竖向放置的平板之间的分辨率 */@media (max-width: 767px) &#123; ... &#125;/* 横向放置的手机及分辨率更小的设备 */@media (max-width: 480px) &#123; ... &#125; 笔记本 1440px 小尺寸笔记本 1280px iPad Pro 1024px iPad 768px iPhone6/7/8 414px 使用示例1234567891011121314151617181920212223242526272829303132333435363738/*当页面宽度小于 960px 的时候执行包裹的css*/@media screen and (max-width: 960px)&#123; body&#123; background: #000; &#125;&#125;/*当页面宽度大于 960px 的时候执行包裹的css*/@media screen and (min-width:960px)&#123; body&#123; background:red; &#125;&#125;/*当设备的最大宽度等于 960px 的时候执行包裹的css*/@media screen and (max-device-width:960px)&#123; body&#123; background:red; &#125;&#125;/*当页面宽度大于 960px 且小于 1440px 的时候执行包裹的css*/@media screen and (min-width:960px) and (max-width:1440px)&#123; body&#123; background:red; &#125;&#125;/* 浏览器支持flex 且 页面宽度大于 900px 的时候执行包裹的css */@supports (display: flex) &#123; @media screen and (min-width: 900px) &#123; article &#123; display: flex; &#125; &#125;&#125; 一些链接@media说明 https://developer.mozilla.org/en-US/docs/Web/CSS/@media @media示例 https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries 设备分辨率查询网址 http://viewportsizes.mattstow.com/","categories":[],"tags":[{"name":"media","slug":"media","permalink":"http://bigma.cc/tags/media/"},{"name":"媒体查询","slug":"媒体查询","permalink":"http://bigma.cc/tags/媒体查询/"},{"name":"分辨率","slug":"分辨率","permalink":"http://bigma.cc/tags/分辨率/"},{"name":"css","slug":"css","permalink":"http://bigma.cc/tags/css/"}]},{"title":"使用Jenkins实现自动化部署","slug":"使用Jenkins实现自动化部署","date":"2018-07-05T15:51:58.000Z","updated":"2023-09-06T14:03:24.664Z","comments":true,"path":"2018/07/05/使用Jenkins实现自动化部署/","link":"","permalink":"http://bigma.cc/2018/07/05/使用Jenkins实现自动化部署/","excerpt":"","text":"系统环境为阿里云 CentOS 8.0 下载安装12345sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.keyyum install jenkins Jenkins 依赖JAVA 如果没有需要安装12345678# 检查时否安装java -version# centOS 需要安装 openjdk 的java ,搜索可用的包yum search openjdk# 安装yum install java-1.8.0-openjdk 启动 Jenkins1234sudo service jenkins start# 守护程序sudo chkconfig jenkins on Jenkins 将启动在 8080 端口 Nginx 反向代理设置12345678910111213141516171819server &#123; listen 80; server_name example.com; # 这里配置域名 access_log off; index index.html index.htm index.php; #error_page 404 /404.html; #error_page 502 /502.html; location /&#123; proxy_pass http://localhost:8080/; proxy_redirect http://localhost:8080 $scheme://example.com; proxy_redirect off; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-NginX-Proxy true; &#125;&#125; 重启 nginx1service nginx restart 问题反向代理设置有误解决办法： 打开浏览器进入 Jenkins 系统管理 -&gt; 系统设置 -&gt; Jenkins URL 在域名后面加上 :8080 不推荐使用 JNLP3-connect 协议1This Jenkins instance uses deprecated protocols: JNLP3-connect. It may impact stability of the instance. If newer protocol versions are supported by all system components (agents, CLI and other clients), it is highly recommended to disable the deprecated protocols. See Protocol Configuration. 意思是 Jenkins 不推荐使用 JNLP3-connect 协议，会影响实例的稳定性。如果所有系统组件（代理，CLI和其他客户端）都支持较新的协议版本，则强烈建议禁用已弃用的协议。 解决办法： 系统管理 -&gt;全局安全配置 -&gt;点击代理中的代理协议 -&gt;取消Java Web Start Agent Protocol/1Java Web Start Agent Protocol/2Java Web Start Agent Protocol/3 前面的勾 -&gt;保存 执行 Shell 脚本权限不够的问题有时部署时需要用到 Shell 命令，Jenkins是没有权限执行的。 解决办法： 修改Jenkins配置文件 123vim /etc/sysconfig/jenkins# 修改 $JENKINS_USER 为 root$JENKINS_USER=\"root\" 设置相关权限 123chown -R root:root /var/lib/jenkinschown -R root:root /var/cache/jenkinschown -R root:root /var/log/jenkins 重启服务并检查权限 12345# 重启 jenkins 服务service jenkins restart# 检查权限ps -ef | grep jenkins","categories":[],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://bigma.cc/tags/Jenkins/"}]},{"title":"sass 和 compass 安装使用","slug":"Sass","date":"2018-06-03T15:23:15.000Z","updated":"2023-09-06T14:03:24.660Z","comments":true,"path":"2018/06/03/Sass/","link":"","permalink":"http://bigma.cc/2018/06/03/Sass/","excerpt":"","text":"sass 和 compass 安装使用下载 Rubyhttps://rubyinstaller.org/downloads/选择 WITHOUT DEVKIT X64 版本 安装 Ruby点击安装文件 全部默认项安装，安装完成后跳出一个命令行窗口，ctrl + C 结束即可。在命令行下输入 ruby -v 检查是否安装成功。 更换 gem 源123456789101112# 1.删除原gem源gem sources --remove https://rubygems.org/# 2.添加国内淘宝源gem sources -a https://gems.ruby-china.com/# 3.打印是否替换成功gem sources -l# 4.更换成功后打印如下*** CURRENT SOURCES ***https://ruby.taobao.org/ 安装 Sass 和 Compass12gem install sassgem install compass 安装完成后 使用 -v 命令检查是否安装成功123456sass -vcompass -v​```bash更新 sass​```bashgem update sass 编译12345678910111213# 单文件转换命令sass input.scss output.css# 单文件监听命令sass --watch input.scss:output.css# 如果你有很多的sass文件的目录，你也可以告诉sass监听整个目录：sass --watch app/sass:public/stylesheets# 在末尾添加 --style compressed 可将生成的css压缩sass --watch app/assets/scss/index.scss:app/assets/css/index.css --style compressed# 其它参数请参考官方文档 compass 创建项目1compass create youProjectName config.rb 为配置文件其中加入 sourcemap = true 可以生成 map 文件12#### 编译compass watch 一些问题 编译时提示 Line 123: Invalid GBK character &quot;\\xE4&quot; 原因是有中文字符的注释，或是引用的 scss 文件中有中文 解决办法：打开 C:\\Ruby25-x64\\lib\\ruby\\gems\\2.5.0\\gems\\sass-3.5.6\\lib\\sass\\engine.rb 文件 12# 在所有的 `require` 之后添加一句 Encoding.default_external = Encoding.find('utf-8') 注意：路径中的 sass-3.5.6 可能有多个版本 必须都添加才可以 官方文档Sass http://sass-lang.com/documentation/file.SASS_REFERENCE.htmlCompass http://compass-style.org/help/","categories":[],"tags":[{"name":"sass","slug":"sass","permalink":"http://bigma.cc/tags/sass/"},{"name":"compass","slug":"compass","permalink":"http://bigma.cc/tags/compass/"}]},{"title":"关于javascript中 ++i 与 i++ 的理解","slug":"关于javascript中 ++i 与 i++ 的理解","date":"2018-04-11T13:34:21.000Z","updated":"2023-09-06T14:03:24.665Z","comments":true,"path":"2018/04/11/关于javascript中 ++i 与 i++ 的理解/","link":"","permalink":"http://bigma.cc/2018/04/11/关于javascript中 ++i 与 i++ 的理解/","excerpt":"","text":"++i 与 i++ 单独出现的时候并没有什么区别 都是在 i 的基础上 自增 1如下12345678let i=1;i++;console.log(i);//i 为 2let j=1;++j;console.log(j)//j 也为 2 在有表达式的情况下 ++i 会先自增1再计算表达式 i++ 会先计算表达式的值再自增1 123456789let j=1;let b = ++j;console.log(b); //2console.log(j); //2let i=1;let a = i++;console.log(a); //1console.log(i); //2 可以这么理解12345678910let j=1;let b = ++j;//相当于b = j+1;let i=1;let a = i++;//相当于a = i;i = i+1;","categories":[],"tags":[]},{"title":"docker 的使用体验","slug":"docker的使用体验","date":"2018-04-06T14:39:09.000Z","updated":"2023-09-06T14:03:24.661Z","comments":true,"path":"2018/04/06/docker的使用体验/","link":"","permalink":"http://bigma.cc/2018/04/06/docker的使用体验/","excerpt":"","text":"基于 windows 10 操作系统 下载 https://www.docker-cn.com/community-edition#/download windows 系统下载 Docker CE for Windows(stable) 安装后可能需要重启。 修改为国内镜像 windows C:\\Users\\你的用户名.docker\\daemon.json Linux /etc/docker/daemon.json 123&#123; \"registry-mirrors\": [\"https://registry.docker-cn.com\"]&#125; 修改后重启 docker 右键通知托盘里的 Docker 图标 选择 Restart 即可 容器介绍 一个 image 文件可生成多个 容器实例文件 image 可继承其他的 image 文件，一般都是继承 image 再添加自己的内容形成自己的 image 容器运行后可自动停止，也可持续运行 容器停止后容器文件不会被删除 容器在各系统上是通用的 常用命令1234567891011121314151617181920212223242526272829303132333435363738# 验证安装$ docker version# 或$ docker info# 列出本机 image 文件$ docker image ls# 删除 image$ docker image rm [imageName]# 从仓库抓取 image 以下命令中 library 为组名称，library 为官方默认组，可忽略。$ docker image pull library/hello-world# 运行 image 文件 以下命令中 container run 如果本地没有该 image 会自动 pull 该 image $ docker container run hello-world# 列出当前正在运行的容器$ docker container ls# 或$ docker ps# 列出所有容器，包括已停止运行的容器$ docker container ls -all# 或$ docker ps -a# 手动终止容器$ docker container kill [containerID]# 停止容器$ docker container stop [containerNAME]# 删除容器文件$ docker container rm [containerID]# 拷贝文件 注意最后的 . 是拷贝到当前目录$ docker container cp [containerNAME]:/etc/nginx . 批量操作命令1234567891011# 停用全部容器$ docker stop $(docker ps -q)# 删除全部容器$ docker rm $(docker ps -aq)# 停用并删除容器$ cker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)# 批量删除名字为 none 的 image$ docker images|grep none|awk '&#123;print $3 &#125;'|xargs docker rmi ####发布 image 命令1234567891011# 登陆 dockerdocker login# 给 image 打上 Tagdocker tag &lt;image&gt; username/repository:tag# 上传到 Docker Hubdocker push username/repository:tag# 运行在线的 imagedocker run username/repository:tag 创建定制的 image.dockerignore 忽略文件123.gitnode_modulesnpm-debug.log Dockerfile12345678910111213141516171819# 继承官网 node image 版本 8.4FROM node:8.4# 当前目录所有文件 拷贝到 image 文件的 /app 目录COPY . /app# 指定工作路径为 /appWORKDIR /app# 在 /app 目录下，运行 npm install 命令。安装后的依赖将打包进 image 文件# RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件RUN npm install --registry=https://registry.npm.taobao.org# 开放 3000 端口，允许外部连接该端口EXPOSE 3000# 容器运行后自动执行的命令# 指定了CMD命令以后，docker container run命令就不能附加命令了CMD node demos/01.js 创建image1234$ docker image build -t test-demo:0.0.1 .# -t imageName# :Tag 标签一般用来表示版本号# . 路径 . 代表当前路径 生成容器12345$ docker container run -p 8000:3000 -it koa-demo /bin/bash# -p 8000:3000 容器的 3000 端口映射到本机 8000 端口# -it 容器的 Shell 映射到当前 Shell# koa-demo image 名字# /bin/bash 容器启动后，内部第一个执行的命令。这里是启动 Bash 创建 Nginx 服务器1234567891011121314151617181920212223$ docker container run \\ --rm \\ --name mynginx \\ --volume \"$PWD/html\":/usr/share/nginx/html \\ --volume \"$PWD/conf\":/etc/nginx \\ -p 127.0.0.2:8080:80 \\ -p 127.0.0.2:8081:443 \\ -d \\ nginx$ docker container run \\ --rm \\ --name mynginx \\ --volume d:/code/dockerHello:/usr/share/nginx/html \\ -p 127.0.0.2:8080:80 \\ -d \\ nginx# -d：在后台运行# -p ：容器的80端口映射到127.0.0.2:8080# --rm：容器停止运行后，自动删除容器文件# --name：容器的名字为mynginx# --volume 目录html，映射到容器的网页文件目录/usr/share/nginx/html 需要在 docker 里设置共享磁盘 一般容器里的内容不能持久化，需要映射到本地的目录 填坑 推荐使用 PowerShell git的Shell 在执行 -ti 命令时会有问题。 在 windows 下 容器内的 webpack gulp等构建工具是监测不到文件变化的，Linux 可以，windows下是先虚拟了个 docker 然后 container 是再虚拟一层。 docker 的 image 文件在哪？image 很空间，随便搞搞几个G就出去了。在 windows 下其实是用 Hyper-V 虚拟的，所以只有一个文件，在以下目录中。 C:\\Users\\Public\\Documents\\Hyper-V\\Virtual hard disks 参考文章http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://bigma.cc/tags/docker/"}]},{"title":"javascript高级程序设计-阅读笔记","slug":"javascript高级程序设计-阅读笔记","date":"2018-03-28T14:39:09.000Z","updated":"2023-09-06T14:03:24.662Z","comments":true,"path":"2018/03/28/javascript高级程序设计-阅读笔记/","link":"","permalink":"http://bigma.cc/2018/03/28/javascript高级程序设计-阅读笔记/","excerpt":"仅记录个人认为的重点内容 持续更新","text":"仅记录个人认为的重点内容 持续更新 第一章 javascript 简介javascript 由以下三部分组成 ECMAScript DOM BOM ECMAScript 由以下组成 语法 类型 语句 关键字 保留字 操作符 对象 DOM 视图，事件，样式，遍历和范围 BOM 弹出新浏览器窗口 移动、缩放、关闭浏览器窗口 提供浏览器详细信息的 navigator 对象 提供浏览器所加载页面的详细信息的 location 对象 提供用户显示器分辨率详细信息的 screen 对象 对 cookies 的支持 像 XMLHttpReqquest 和 IE 的 ActiveXobject 这样的自定义对象 第二章 HTML中使用 javascript\\&lt;script> 属性 async 异步加载 &lt;script async src=&quot;exampel.js&quot;&gt;&lt;/script&gt; defer 延迟加载 &lt;script defer=&quot;defer&quot; src=&quot;exampel.js&quot;&gt;&lt;/script&gt; type text/javascript \\&lt;noscript> 元素如果浏览器不支持脚本或被禁用将显示其中的内容123&lt;noscript&gt; &lt;p&gt;需要浏览器支持 javascript &lt;/p&gt;&lt;/noscript&gt; 第三章 基本概念 区分大小写 标识符 第一个字符 字母 下划线 美元符号 字母 下划线 美元符号 和 数字 语句 一般不建议省略分号 if 语句中建议使用 代码块 {} 变量 声明一个变量 若未赋值，那么该变量会有一个特殊的值 undefined 不推荐通过赋值改变变量的数据类型，但这是有效的 在函数内 var 一个变量，退出函数后会被销毁。如果不使用 var 那么将是一个全局变量 一次声明多个变量 var message=&quot;hi&quot;, age 数据类型 基本数据类型 Undefined Null Boolean Number String 复杂数据类型 Object typeof 操作符 使用 typeof(message) 或 typeof message 可返回 message 的数据类型 undefined 如果值未定义 boolean 如果是布尔值 string 如果是字符串 number 如果是数值 object 如果是对象或 null 注意 null也是个对象 function 如果值为一个函数 Undefined 如果声明了一个变量未赋值那么是 undefined ，如果没有声明就调用 会报错 未初始化的变量和声明未赋值的变量执行 typeof 操作符都会返回 undefined Null null 值表示一个空对象指针 所以null 在执行 typeof 的时候会返回 object 要定义 对象 可以初始化为 null undefined 派生自 null 所以 undefined == null 但 undefined === null 为 false Boolean String 非空字符串 为 true; “”空字符串 为 false Number 任何非零数值包括无穷大 为 true; 0 和 NaN 为 false Object 任何对象 为 true ; null 为 false Undefined 为 false Number 可使用 十进制 八进制 十六进制 无效的八进制将会去掉 第一位的 0 并被当作 十进制 浮点 .1 有效但不推荐 会舍弃小数点后无意义的值 如1.0 为 1 浮点计算精度问题 0.1+0.2 = 0.30000000000000004 (IEEE754 数值浮点计算通病) 最大值 Number.MAX_VALUE 最小值 Number.MIN_VALUE 超过最大值 为Infinity 正无穷；超过最小值 为 -Infinity 负无穷； ifFinite() 若为 true 则说明数值在范围之内 NaN == Nan 为 false ; 与NaN计算都为 NaN 如 NaN/10 为 NaN isNaN() 尝试将参数转会数值再判断 “10” 可转换为 10； “blue” 不能转换为数值 ； true 可转换为 1；false 转换为 0 数值转换 String 类型 字符串由 双引号，或单引号表示。 字符字面量 \\n \\t \\b \\r \\f \\ \\’ \\” \\xnn \\unnnn 字符串定义后不可改变，只能销毁后重新赋值。导致某些旧浏览器拼接字符串效率低下。 数值、布尔值、对象和字符串都可以使用 toString(进制数，默认10) 转换为 字符串。null undefinde 没有这个方法 String() 方法,值由 toString()方法则使用。null 返回 null undefinde 返回 undefinde Object 类型 对象为一组数据和功能的集合 创建对象 var o = new Object(); 可省略() 但不推荐 位操作符 ~ 按位非 操作数的负值减1 &amp; 按位与","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://bigma.cc/tags/js/"}]},{"title":"控制反转与依赖注入[转载]","slug":"控制反转与依赖注入","date":"2018-03-24T12:22:13.000Z","updated":"2023-09-06T14:03:24.665Z","comments":true,"path":"2018/03/24/控制反转与依赖注入/","link":"","permalink":"http://bigma.cc/2018/03/24/控制反转与依赖注入/","excerpt":"之前一直不理解控制反转与依赖注入，直到我看到了这篇。","text":"之前一直不理解控制反转与依赖注入，直到我看到了这篇。先说下自己的理解，calss A的内部需要实例化 class B，那么 class A就依赖于 class B，如果 class B 出现问题，那么势必导致 class A 也出现问题，这种就是依赖关系。如何解决？就是不在 class A 中控制实例化 class B 而是将 解决方案 作为参数注入到 class A中，那至于用什么解决方案，就交给第三方来控制（IOC）。那么这种思想就是控制反转，而实现的方式就是依赖注入。 第一章：小明和他的手机从前有个人叫小明 小明有三大爱好，抽烟，喝酒…… 咳咳，不好意思，走错片场了。应该是逛知乎、玩王者农药和抢微信红包我们用一段简单的伪代码，来制造一个这样的小明12345678910111213141516171819202122class Ming extends Person&#123; private $_name; private $_age; function read() &#123; //逛知乎 &#125; function play() &#123; //玩农药 &#125; function grab() &#123; //抢红包 &#125;&#125; 但是，小明作为一个人类，没有办法仅靠自己就能实现以上的功能，他必须依赖一部手机，所以他买了一台iphone6，接下来我们来制造一个iphone6 1234567891011121314151617class iPhone6 extends Iphone&#123; function read($user=\"某人\") &#123; echo $user.\"打开了知乎然后编了一个故事 \\n\"; &#125; function play($user=\"某人\") &#123; echo $user.\"打开了王者农药并送起了人头 \\n\"; &#125; function grab($user=\"某人\") &#123; echo $user.\"开始抢红包却只抢不发 \\n\"; &#125;&#125; 小明非常珍惜自己的新手机，每天把它牢牢控制在手心里，所以小明变成了这个样子 123456789101112131415161718192021222324252627282930313233class Ming extends Person&#123; private $_name; private $_age; public function __construct() &#123; $this-&gt;_name = '小明'; $this-&gt;_age = 26; &#125; function read() &#123; //…… 省略若干代码 (new iPhone6())-&gt;read($this-&gt;_name); //逛知乎 &#125; function play() &#123; //…… 省略若干代码 (new iPhone6())-&gt;play($this-&gt;_name);//玩农药 &#125; function grab() &#123; //…… 省略若干代码 (new iPhone6())-&gt;grab($this-&gt;_name);//抢红包 &#125;&#125; 今天是周六，小明不用上班，于是他起床，并依次逛起了知乎，玩王者农药，并抢了个红包。 1234$ming = new Ming(); //小明起床$ming-&gt;read();$ming-&gt;play();$ming-&gt;grab(); 这个时候，我们可以在命令行里看到输出如下123小明打开了知乎然后编了一个故事 小明打开了王者农药并送起了人头 小明开始抢红包却只抢不发 这一天，小明过得很充实，他觉得自己是世界上最幸福的人。 第二章： 小明的快乐与忧伤小明和他的手机曾一起度过了一段美好的时光，一到空闲时刻，他就抱着手机，逛知乎，刷微博，玩游戏，他觉得自己根本不需要女朋友，只要有手机在身边，就满足了。 可谁能想到，一次次地系统更新彻底打碎了他的梦想，他的手机变得越来越卡顿，电池的使用寿命也越来越短，一直到某一天的寒风中，他的手机终于耐不住寒冷，头也不回地关了机。 小明很忧伤，他意识到，自己要换手机了。 为了能获得更好的使用体验，小明一咬牙，剁手了一台iphoneX，这部手机铃声很大，电量很足，还能双卡双待，小明很喜欢，但是他遇到一个问题，就是他之前过度依赖了原来那一部iPhone6，他们之间已经深深耦合在一起了，如果要换手机，他就要拿起刀来改造自己，把自己体内所有方法中的iphone6 都换成 iphoneX。 经历了漫长的改造过程，小明终于把代码中的 iphone6 全部换成了 iphoneX。虽然很辛苦，但是小明觉得他是快乐的。 于是小明开开心心地带着手机去上班了，并在回来的路上被小偷偷走了。为了应急，小明只好重新使用那部刚刚被遗弃的iphone6，但是一想到那漫长的改造过程，小明的心里就说不出的委屈，他觉得自己过于依赖手机了，为什么每次手机出什么问题他都要去改造他自己，这不仅仅是过度耦合，简直是本末倒置，他向天空大喊，我不要再控制我的手机了。 天空中的造物主，也就是作为程序员的我，听到了他的呐喊，我告诉他，你不用再控制你的手机了，交给我来管理，把控制权交给我。这就叫做控制反转。 第三章：造物主的智慧小明听到了我的话，他既高兴，又有一点害怕，他跪下来磕了几个头，虔诚地说到：“原来您就是传说中的造物主，巴格梅克上神。我听到您刚刚说了 控制反转 四个字，就是把手机的控制权从我的手里交给你，但这只是您的想法，是一种思想罢了，要用什么办法才能实现控制反转，又可以让我继续使用手机呢？” “呵“，身为造物主的我在表现完不屑以后，扔下了四个大字，“依赖注入！” 接下来，伟大的我开始对小明进行惨无人道的改造，如下 12345678910111213141516171819202122232425262728293031323334353637class Ming extends Person&#123; private $_name; private $_age; private $_phone; //将手机作为自己的成员变量 public function __construct($phone) &#123; $this-&gt;_name = '小明'; $this-&gt;_age = 26; $this-&gt;_phone = $phone; echo \"小明起床了 \\n\"; &#125; function read() &#123; //…… 省略若干代码 $this-&gt;_phone-&gt;read($this-&gt;_name); //逛知乎 &#125; function play() &#123; //…… 省略若干代码 $this-&gt;_phone-&gt;play($this-&gt;_name);//玩农药 &#125; function grab() &#123; //…… 省略若干代码 $this-&gt;_phone-&gt;grab($this-&gt;_name);//抢红包 &#125;&#125; 接下来，我们来模拟运行小明的一天 12345678$phone = new IphoneX(); //创建一个iphoneX的实例if($phone-&gt;isBroken())&#123;//如果iphone不可用，则使用旧版手机 $phone = new Iphone6();&#125;$ming = new Ming($phone);//小明不用关心是什么手机，他只要玩就行了。$ming-&gt;read();$ming-&gt;play();$ming-&gt;grab(); 我们先看一下iphoneX 是否可以使用，如果不可以使用，则直接换成iphone6,然后唤醒小明，并把手机塞到他的手里，换句话说，把他所依赖的手机直接注入到他的身上，他不需要关心自己拿的是什么手机，他只要直接使用就可以了。 这就是依赖注入。 第四章：小明的感悟小明的生活开始变得简单了起来，而他把省出来的时间都用来写笔记了，他在笔记本上这样写到 我曾经有很强的控制欲，过度依赖于我的手机，导致我和手机之间耦合程度太高，只要手机出现一点点问题，我都要改造我自己，这实在是既浪费时间又容易出问题。自从我把控制权交给了造物主，他每天在唤醒我以前，就已经替我选好了手机，我只要按照平时一样玩手机就可以了，根本不用关心是什么手机。即便手机出了问题，也可以由造物主直接搞定，不需要再改造我自己了，我现在买了七部手机，都交给了造物主，每天换一部，美滋滋！我也从其中获得了这样的感悟： 如果一个类A 的功能实现需要借助于类B，那么就称类B是类A的依赖，如果在类A的内部去实例化类B，那么两者之间会出现较高的耦合，一旦类B出现了问题，类A也需要进行改造，如果这样的情况较多，每个类之间都有很多依赖，那么就会出现牵一发而动全身的情况，程序会极难维护，并且很容易出现问题。要解决这个问题，就要把A类对B类的控制权抽离出来，交给一个第三方去做，把控制权反转给第三方，就称作控制反转（IOC Inversion Of Control）。控制反转是一种思想，是能够解决问题的一种可能的结果，而依赖注入（Dependency Injection）就是其最典型的实现方法。由第三方（我们称作IOC容器）来控制依赖，把他通过构造函数、属性或者工厂模式等方法，注入到类A内，这样就极大程度的对类A和类B进行了解耦。 第五章 小明的困惑有一天，小明发现自己在想阅读知乎的时候，读到了这样一行文字。未完待续… 本篇转载自知乎胡小国 原文链接","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://bigma.cc/tags/设计模式/"},{"name":"依赖注入","slug":"依赖注入","permalink":"http://bigma.cc/tags/依赖注入/"},{"name":"控制反转","slug":"控制反转","permalink":"http://bigma.cc/tags/控制反转/"}]},{"title":"使用纯css实现radio的美化","slug":"使用纯css实现radio的美化","date":"2018-03-15T08:16:56.000Z","updated":"2023-09-06T14:03:24.665Z","comments":true,"path":"2018/03/15/使用纯css实现radio的美化/","link":"","permalink":"http://bigma.cc/2018/03/15/使用纯css实现radio的美化/","excerpt":"很多时候需要对单选和多选经行美化，因为原生太丑了，而且那么小，要是在手机上可不好点。美化的话你当然可以使用js，但CSS就有简单的办法实现。就是使用“+”这个css选择器即可。","text":"很多时候需要对单选和多选经行美化，因为原生太丑了，而且那么小，要是在手机上可不好点。美化的话你当然可以使用js，但CSS就有简单的办法实现。就是使用“+”这个css选择器即可。css 这个“+”选择器意思是选择同级对象。比如 div + p 是指 div 后面所有同级的 p 元素，不包含父元素之外的。相应的还有一个 “&gt;” 选择器，div &gt; p 就是选择div这个父元素里所有的p元素了。 演示链接 https://stackblitz.com/edit/radio-beautiful?file=style.css index.html1234567&lt;h1&gt;css input 美化&lt;/h1&gt;&lt;div class=\"box\"&gt; &lt;input id=\"ra1\" name=\"a\" checked type=\"radio\"&gt;&lt;label for=\"ra1\"&gt;选择1&lt;/label&gt;&lt;/div&gt;&lt;div class=\"box\"&gt; &lt;input id=\"ra2\" name=\"a\" type=\"radio\"&gt;&lt;label for=\"ra2\"&gt;选择2&lt;/label&gt;&lt;/div&gt; css12345678910111213141516171819202122h1, h2 &#123; font-family: Lato;&#125;body&#123; color: #fff; font-size: 12px;&#125;label&#123; display: block; width: 50px; height: 20px; background: red; text-align: center;&#125;input:checked+label&#123; background: green;&#125;.box&#123; width: 60px; height: 40px; float: left;&#125; 用到项目中的效果","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://bigma.cc/tags/css/"},{"name":"radio","slug":"radio","permalink":"http://bigma.cc/tags/radio/"},{"name":"input","slug":"input","permalink":"http://bigma.cc/tags/input/"},{"name":"美化","slug":"美化","permalink":"http://bigma.cc/tags/美化/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2018-03-14T14:19:32.000Z","updated":"2023-09-06T14:03:24.659Z","comments":true,"path":"2018/03/14/Git常用命令/","link":"","permalink":"http://bigma.cc/2018/03/14/Git常用命令/","excerpt":"Git 一些常用命令，备忘录","text":"Git 一些常用命令，备忘录 生成SSH key12345678910111213141516# 这个指令会要求你提供一个位置和文件名去存放键值对和密码，你可以点击3次Enter键去使用默认值ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\"# 输出公钥 也可以判断本地是否有公钥cat ~/.ssh/id_rsa.pub# 复制公钥到剪切板，如果不起作用使用上面的命令复制即可clip &lt; ~/.ssh/id_rsa.pub #windowspbcopy &lt; ~/.ssh/id_rsa.pub #macxclip -sel clip &lt; ~/.ssh/id_rsa.pub #linux# 测试链接ssh -T git@gitee.com #码云ssh -T git@github.com #github# 首次使用需要确认并添加主机到本机SSH可信列表# Hi XXX! You've successfully authenticated, but Gitee.com does not provide shell access. 表示添加成功 设置全局信息123# 这里的名字会出现在提交记录里，团队合作是最好写真实的名字，方便找人git config --global user.name \"name\"git config --global user.email \"ex@mail.com\" 创建一个git仓库123git init# 创建一个裸仓库git init --bare 添加远程仓库1git remote add origin git@github.com:windy0220/vuePos.git 克隆123$ git clone git@github.com:windy0220/vuePos.git# 克隆到制定文件夹 localFolder$ git clone git@github.com:windy0220/vuePos.git localFolder 提交一个版本12345678# 添加到暂存git add -A# 提交版本git commit -m \"版本说明\"# 推送到仓库git push# 分支推送git push [远程主机名] [本地分支]:[远程分支] 获取状态1234567git status# 简略状态git status -s# 暂存文件与未暂存文件对比git diff# 暂存文件与已提交的版本文件对比git diff --staged 查看历史记录123456789101112# 列出所有更新git log# -p显示每次提交的内容差异 -2显示最近两次提交git log -p -2# 显示简略统计git log --stat# 更好看的格式git log --pretty=oneline/short/full/fuller# 定制要显示的记录格式git log --pretty=format:\"%h - %an, %ar : %s\"# 展示分支合并历史git log --pretty=format:\"%h %s\" --graph 分支123456789101112131415161718192021222324#查看远程分支 git branch -r#查看本地分支git branch#创建本地分支 git branch 分支名称#分支推送 git push origin 分支名称#切换分支 git checkout 分支名称#删除本地分支 强制删除用 -Dgit branch -d 分支名称 #合并分支 先要切换到主分支，然后合并git merge 次分支名称# 在本地新建分支，并自动切换到该本地分支，本地分支会和远程分支建立映射关系(可以使用 git pull)git checkout -b 本地分支 origin/远程分支# 本地新建分支，但是不会自动切换到该本地分支，需要手动checkout，本地分支不会和远程分支建立映射关系git fetch origin 远程分支:本地分支# 建立本地分支与远程分支的映射关系git branch -u origin/addFile# 取消本地分支与远程分支的映射关系git branch --unset-upstream# 查看映射关系git branch -vv 返回之前的版本123456# HEAD为当前版本 上个版本为HEAD^ 上上个版本为HEAD^^ 上100个版本 HEAD~100 或使用 commit_idgit reset --hard HEAD/commit_id # 强制push到远程仓库 确保本地代码为最新且没有其他人在push 否则会丢失数据git push &lt;remote&gt; HEAD --force# --force可简写git push -f origin master 撤销操作12345678# 重新提交git commit --amend# 取消暂存git reset HEAD filename# 撤销修改，用初始文件覆盖工作目录中已修改的文件git checkout --filename# 取消某次提交，只取消commit记录git reset --soft HEADID 删除操作123456789101112# 从暂存区和工作目录移除文件git rm filename# 强制从暂存区删除文件git rm -f filename# 从git仓库删除文件 但保留在本地磁盘git rm --cached README# 从git仓库删除目录 但保留在本地磁盘git rm -r --cached filePath# /删除log/目录下的一.log结尾的文件git rm log/\\*.log# 删除末尾带~的文件git rm \\*~ 移动改名1git mv file_from file_to stash 操作使用场景：如果正在进行功能开发，做到一半，这时候需要在别的分支上修改bug又不想提交，可以使用stash将当前的修改的内容隐藏起来。 1234567891011# 将修改的内容隐藏git stash# 显示隐藏的列表git stash list# 恢复最后隐藏的那些内容并在saash列表中删除git stash pop# 恢复stash 只有一个时可以省略 stash@&#123;0&#125;git stash apply stash@&#123;0&#125;# 删除stashgit stash drop stash@&#123;1&#125; 忽略文件https://github.com/github/gitignore 一些会出现的问题出现 “warning: LF will be replaced by CRLF in ……”12 # 设置后删除.git重新建立git config --global core.autocrlf false","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://bigma.cc/tags/Git/"}]},{"title":"使用命令行上传文件 SCP","slug":"使用命令行上传文件","date":"2018-03-10T14:25:10.000Z","updated":"2023-09-06T14:03:24.664Z","comments":true,"path":"2018/03/10/使用命令行上传文件/","link":"","permalink":"http://bigma.cc/2018/03/10/使用命令行上传文件/","excerpt":"一直使用 git bash 命令行的 ssh 工具连接服务器，部署或是配置一些文件，但要上传项目的时候还是要开一个ftp，再打开ftp工具经行上传，很是麻烦。后来发现命令行下也提供了上传和下载文件的工具，这就是 SCP。","text":"一直使用 git bash 命令行的 ssh 工具连接服务器，部署或是配置一些文件，但要上传项目的时候还是要开一个ftp，再打开ftp工具经行上传，很是麻烦。后来发现命令行下也提供了上传和下载文件的工具，这就是 SCP。输入 scp 会显示帮助信息，证明是这个命令是可用的。我是在 windows 下使用的 git bash 命令行。1234$ scpusage: scp [-346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file] [-l limit] [-o ssh_option] [-P port] [-S program] [[user@]host1:]file1 ... [[user@]host2:]file2 上传文件到服务器1scp localPath/filename username@servername:remotePath 我一般是在要上传的文件所在的目录里右键 Git Bash Here 打开命令行后，本地就直接输入文件名好了，省去了输入本地路径。当然远程的路径是省不了的。比如我要上传 /d/phpStudy/WWW/wx 下的 test.txt 文件到服务器的 /data/wwwroot/ 目录1$ scp test.txt username@servername:/data/wwwroot/ 回车之后提示输入服务器密码，输入回车，就上传上去了。1test.txt 100% 0 0.0KB/s 00:00 上传目录到服务器1scp -r localDir username@servername:remotePath 从服务器下载文件1scp username@servername:/remotePath/filename localPath 从服务器上下载目录1scp -r username@servername:/remotePath/remoteDir localPath/localDir","categories":[],"tags":[{"name":"scp","slug":"scp","permalink":"http://bigma.cc/tags/scp/"},{"name":"ssh","slug":"ssh","permalink":"http://bigma.cc/tags/ssh/"}]},{"title":"Vue-Cli学习手记","slug":"Vue-Cli学习手记","date":"2018-02-24T15:23:15.000Z","updated":"2023-09-06T14:03:24.660Z","comments":true,"path":"2018/02/24/Vue-Cli学习手记/","link":"","permalink":"http://bigma.cc/2018/02/24/Vue-Cli学习手记/","excerpt":"vueCli 学习笔记github https://github.com/windy0220/vueStudy","text":"vueCli 学习笔记github https://github.com/windy0220/vueStudy 目录 VueCli 安装 目录结构 重要文件解读 vue-router 增加一个Hi的路由和页面 router-link制作导航 配置子路由 传参 单页面多路由区域操作 通过 url 传参 重定向 别名 路由过渡动画 404页面 URL Mode 路由配置文件中的钩子 组件中的钩子函数 编程式导航 Vuex 安装vuex 简化state的调用 getters过滤器 actions异步修改状态 modue模块组 安装VueCli安装cnpm1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 安装 vue-cli1cnpm i vue-cli -g 查看 vue-cli 版本1vue -V 初始化项目1vue init webpack &lt;项目名称&gt; Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写 Project description:项目描述 Author：作者 Install vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择Y Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。输入n， setup unit tests with Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，输入n。 Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，输入n。 进入项目执行 cnpm i 安装依赖包 运行 npm run dev 启动服务环境 运行 npm run build 打包文件 将 dist 文件夹下的内容上传到服务器即可。 将 config/index.js 中的 build 下的 assetsPublicPath: ‘/‘ 修改为 assetsPublicPath: ‘./‘ 目录结构12345678910111213141516171819202122232425262728|-- build // 项目构建(webpack)相关代码| |-- build.js // 生产环境构建代码| |-- check-version.js // 检查node、npm等版本| |-- dev-client.js // 热重载相关| |-- dev-server.js // 构建本地服务器| |-- utils.js // 构建工具相关| |-- webpack.base.conf.js // webpack基础配置 *| |-- webpack.dev.conf.js // webpack开发环境配置| |-- webpack.prod.conf.js // webpack生产环境配置|-- config // 项目开发环境配置| |-- dev.env.js // 开发环境变量| |-- index.js // 项目一些配置变量| |-- prod.env.js // 生产环境变量| |-- test.env.js // 测试环境变量|-- src // 源码目录| |-- components // vue公共组件| |-- store // vuex的状态管理| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件|-- static // 静态文件，比如一些图片，json数据等| |-- data // 群聊分析得到的数据用于数据可视化|-- .babelrc // ES6语法编译配置 *|-- .editorconfig // 定义代码格式 *|-- .gitignore // git上传需要忽略的文件格式|-- README.md // 项目说明|-- favicon.ico|-- index.html // 入口页面|-- package.json // 项目基本信息 重要文件解读main.js文件解读main.js是整个项目的入口文件,在src文件夹下：12345678910111213import Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = false //生产环境提示，这里设置成了false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 通过代码可以看出这里引进了App的组件和的模板，它是通过 import App from ‘./App’这句代码引入的。 我们找到App.vue文件，打开查看。 App.vue文件解读1234567891011121314151617181920212223&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;app&apos;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; app.vue文件我们可以分成三部分解读， 标签包裹的内容：这是模板的HTMLDom结构，里边引入了一张图片和标签，标签说明使用了路由机制。我们会在以后专门拿出一篇文章讲Vue-router。 标签包括的js内容：你可以在这里些一些页面的动态效果和Vue的逻辑代码。 标签包裹的css内容：这里就是你平时写的CSS样式，对页面样子进行装饰用的，需要特别说明的是你可以用来声明这些css样式只在本模板中起作用。 router/index.js 路由文件123456789101112131415import Vue from 'vue'import Router from 'vue-router'import Hello from '@/components/Hello'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'Hello', component: Hello &#125; ]&#125;) 我们可以看到 import Hello from ‘@/components/Hello’这句话， 文件引入了/components/Hello.vue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示Hello.vue的内容。 Hello.vue文件解读同样分为 &lt;template&gt;&lt;script&gt;&lt;style&gt; 三个部分，以后我们大部分的工作都是写这些.vue结尾的文件。现在我们可以试着改一些内容，然后预览一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;h2&gt;Essential Links&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://vuejs.org&quot; target=&quot;_blank&quot;&gt;Core Docs&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://forum.vuejs.org&quot; target=&quot;_blank&quot;&gt;Forum&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://gitter.im/vuejs/vue&quot; target=&quot;_blank&quot;&gt;Gitter Chat&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://twitter.com/vuejs&quot; target=&quot;_blank&quot;&gt;Twitter&lt;/a&gt;&lt;/li&gt; &lt;br&gt; &lt;li&gt;&lt;a href=&quot;http://vuejs-templates.github.io/webpack/&quot; target=&quot;_blank&quot;&gt;Docs for This Template&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Ecosystem&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;http://router.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vue-router&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://vuex.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vuex&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://vue-loader.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vue-loader&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/vuejs/awesome-vue&quot; target=&quot;_blank&quot;&gt;awesome-vue&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;hello&apos;, data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; vue-router安装 如果安装 vue-cli 的时候安装了 router 则不用再单独安装1cnpm i vue-router --save-dev 解读router/index.js文件我们用vue-cli生产了我们的项目结构，你可以在src/router/index.js文件，这个文件就是路由的核心文件 123456789101112131415import Vue from 'vue' //引入Vueimport Router from 'vue-router' //引入vue-routerimport Hello from '@/components/Hello' //引入根目录下的Hello.vue组件Vue.use(Router) //Vue全局使用Routerexport default new Router(&#123; routes: [ //配置路由，这里是个数组 &#123; //每一个链接都是一个对象 path: '/', //链接路径 name: 'Hello', //路由名称， component: Hello //对应的组件模板 &#125; ]&#125;) 这个路由文件里只配置了一个功能，就是在进入项目时，显示Hello.vue里边的内容代码 增加一个Hi的路由和页面 在src/components目录下，新建 Hi.vue 文件。 编写文件内容，和我们之前讲过的一样，文件要包括三个部分 &lt;template&gt;&lt;script&gt; 和 &lt;style&gt; 。文件很简单，只是打印一句话。 1234567891011121314151617181920&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'hi', data () &#123; return &#123; msg: 'Hi, I am JSPang' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 引入 Hi组件：我们在router/index.js文件的上边引入Hi组件 1import Hi from '@/components/Hi' 增加路由配置：在router/index.js文件的routes[]数组中，新增加一个对象，代码如下。 12345&#123; path:'/hi', name:'Hi', component:Hi&#125; 路由配置文件 1234567891011121314151617181920import Vue from 'vue' //引入Vueimport Router from 'vue-router' //引入vue-routerimport Hello from '@/components/Hello' //引入根目录下的Hello.vue组件import Hi from '@/components/Hi'Vue.use(Router) //Vue全局使用Routerexport default new Router(&#123; routes: [ //配置路由，这里是个数组 &#123; //每一个链接都是一个对象 path: '/', //链接路径 name: 'Hello', //路由名称， component: Hello //对应的组件模板 &#125;,&#123; path:'/hi', name:'Hi', component:Hi &#125; ]&#125;) router-link制作导航1&lt;router-link to=\"/\"&gt;[显示字段]&lt;/router-link&gt; to：是我们的导航路径，要填写的是你在router/index.js文件里配置的path值，如果要导航到默认首页，只需要写成 to=”/” ， [显示字段] ：就是我们要显示给用户的导航名称，比如首页 新闻页。 在 src/App.vue文件中的template里加入下面代码，实现导航。 1234&lt;p&gt;导航 ： &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/hi\"&gt;Hi页面&lt;/router-link&gt;&lt;/p&gt; vue-router配置子路由用 &lt;router-link&gt; 标签增加了两个新的导航链接。123456&lt;p&gt;导航 ： &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; | &lt;router-link to=\"/hi\"&gt;Hi页面&lt;/router-link&gt; | &lt;router-link to=\"/hi/hi1\"&gt;-Hi页面1&lt;/router-link&gt; | &lt;router-link to=\"/hi/hi2\"&gt;-Hi页面2&lt;/router-link&gt;&lt;/p&gt; 把Hi.vue改成一个通用的模板，加入 &lt;router-view&gt; 标签，给子模板提供插入位置“Hi页面1” 和 “Hi页面2” 都相当于“Hi页面”的子页面 坑 vue模板只能有一个根对象 需要用 div 包裹住 router-view 123456789101112131415161718192021&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;router-view class=\"aaa\"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'hi', data () &#123; return &#123; msg: 'Hi, I am JSPang' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 在components目录下新建两个组件模板 Hi1.vue 和 Hi2.vue 新建的模板和Hi.vue没有太多的差别，知识改变了data中message的值，也就是输出的结果不太一样了。 123456789101112131415161718&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'hi', data () &#123; return &#123; msg: 'Hi, I am Hi1!' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 修改router/index.js代码改变我们的路由配置文件就可以了。子路由的写法是在原有的路由配置下加入children字段。1234567891011121314151617181920212223242526import Vue from 'vue'import Router from 'vue-router'import Hello from '@/components/Hello'import Hi from '@/components/Hi'import Hi1 from '@/components/Hi1'import Hi2 from '@/components/Hi2'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'Hello', component: Hello &#125;,&#123; path:'/hi', component:Hi, children:[ &#123;path:'/',component:Hi&#125;, &#123;path:'hi1',component:Hi1&#125;, &#123;path:'hi2',component:Hi2&#125;, ] &#125; ]&#125;) 需要注意的是，在配置路由文件前，需要先用import引入Hi1和Hi2。小坑注意，子路由 不用带 / 传参用name传递参数 在路由文件src/router/index.js里配置name属性。 1234567routes: [ &#123; path: '/', name: 'Hello', component: Hello &#125; ] 模板里(src/App.vue)用$router.name的形势接收，比如直接在模板中显示：注意这里是 route 不是 router 1&lt;p&gt;&#123;&#123; $route.name&#125;&#125;&lt;/p&gt; 通过 标签中的to传参 多数传参是不用name进行传参的，我们用 &lt;router-link&gt; 标签中的 to 属性进行传参，需要您注意的是这里的to要进行一个绑定，写成 :to 1&lt;router-link :to=\"&#123;name:xxx,params:&#123;key:value&#125;&#125;\"&gt;valueString&lt;/router-link&gt; 这里的to前边是带冒号的，然后后边跟的是一个对象形势的字符串. name：就是我们在路由配置文件中起的name值。 params：就是我们要传的参数，它也是对象形势，在对象里可以传递多个值。 修改 src/App.vue 里的 &lt;router-link&gt; 标签1&lt;router-link :to=\"&#123;name:'hi1',params:&#123;username:'windy'&#125;&#125;\"&gt;Hi页面1&lt;/router-link&gt; 把src/reouter/index.js文件里给hi1配置的路由起个name,就叫hi1.1&#123;path:'/hi1',name:'hi1',component:Hi1&#125;, 最后在模板里(src/components/Hi1.vue)用$route.params.username进行接收.1&#123;&#123;$route.params.username&#125;&#125; 单页面多路由区域操作在一个页面上调用多个 &lt;router-view&gt;&lt;/router-view&gt; 并控制所显示的内容。使用 name 来区分。 src/App.vue123&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view name=\"left\" class=\"leftbox\"&gt;&lt;/router-view&gt;&lt;router-view name=\"right\" class=\"rightbox\"&gt;&lt;/router-view&gt; 新建所需的组件 left.vue right1.vue right2.vue 并在 router/index.js 中导入 components 中定义各 router-view 的显示内容 routerViewName:componentName 坑 component 注意加 src/router/index.js 12345678910111213141516171819export default new Router(&#123; routes: [&#123; path: '/', name: 'HelloWorld', components: &#123; left:Left, right:Right1 &#125; &#125;, &#123; path: '/r1', name: 'HelloWorld', components: &#123; left:Left, right:Right2 &#125; &#125;]&#125;) 通过url传参在 src/router/index.js 中的 path 上添加参数绑定 path: &#39;/路径/:参数1/:参数2&#39;, 12345678&#123; path: '/r1/:newsTit/:newsContent', name: 'r1', components: &#123; left:Left, right:Right2 &#125;&#125; 在 App.vue router-link 中加入要传递的参数 1&lt;router-link to=&quot;/r1/新闻标题/新闻内容&quot;&gt;page1&lt;/router-link&gt; 在组件中 使用 接收 12&lt;div class=&quot;tit&quot;&gt;&#123;&#123; $route.params.newsTit &#125;&#125;&lt;/div&gt;&lt;div class=&quot;content&quot;&gt;&#123;&#123; $route.params.newsContent &#125;&#125;&lt;/div&gt; 使用正则来限制出入参数的形式。若参数不符则页面不会显示 1path:&apos;/params/:newsId(\\\\d+)/:newsTitle&apos;, 重定向src/router/index.js1234&#123; path: &apos;/redi&apos;, redirect:&apos;/&apos;&#125; 带参数的重定向1234&#123; path: &apos;/redip/:newsTit/:newsContent&apos;, redirect:&apos;/r1/:newsTit/:newsContent&apos;&#125; 别名alias:&#39;path&#39; 别名的路径可以显示到 url 上，但重定向只是显示重定向后的源地址 src/router/index.js 123456789&#123; path: &apos;/r1/:newsTit/:newsContent&apos;, name: &apos;r1&apos;, alias:&apos;/aliaslink/:newsTit/:newsContent&apos;, components: &#123; left:Left, right:Right2 &#125; &#125;, 路由过渡动画给要添加动画的 router-view 包裹一个 transition 标签123&lt;transition name=&quot;ani&quot; mode=&quot;out-in&quot;&gt; &lt;router-view name=&quot;right&quot; class=&quot;rightbox&quot;&gt;&lt;/router-view&gt;&lt;/transition&gt; 添加 css 样式 12345678910111213.ani-enter&#123; opacity:0;&#125;.ani-leave&#123; opacity: 1;&#125;.ani-enter-active&#123; transition: opacity .5s;&#125;.ani-leave-active&#123; opacity: 0; transition:opacity .5s;&#125; name: 过渡动画的css前缀 ani-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。 ani-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。 ani-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。 ani-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除。 mode: 过度模式 in-out:新元素先进入过渡，完成之后当前元素过渡离开。 out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。 别名或重定向的 view 切换无法触发动画，另外 transition 只能包含一个组 router-view 404如果用户输入的路径在 router 中没有定义，展示该页面 在 src/componets 下新建 Error.vue 组件 在 src/router/index.js 中导入 routes 中定义 src/router/index.js1234&#123; path: &apos;*&apos;, component: Error&#125; URL Mode在 src/router/index.js 中定义 mode: ‘hash’ : url 中带 # mode: ‘hhistory’ : url 中不带＃ 默认值 src/router/index.js1234export default new Router(&#123; mode: &apos;history&apos;, routes: [&#123; .... 路由配置文件中的钩子src/router/index.js12345678910&#123; path:&apos;/hook&apos;, name:&apos;hook&apos;, component:Hook, beforeEnter:(to, from, next)=&gt;&#123; console.log(to) console.log(from) next() &#125; &#125;, to:路由将要跳转的路径信息，信息是包含在对像里边的。 from:路径跳转前的路径信息，也是一个对象的形式。 next:路由的控制参数，常用的有next(true)和next(false)。注意：不写 next() 将导致页面不加载 组件中的钩子函数组件中可以使用两个钩子函数 beforeRouteEnter：在路由进入前的钩子函数。 beforeRouteLeave：在路由离开前的钩子函数。 src/components/Com_Hook.vue12345678910111213141516export default &#123; name: &quot;Com_Hook&quot;, data() &#123; return &#123; msg: &quot;This is my vue Hook 请查看控制台&quot; &#125;; &#125;, beforeRouteEnter: (to, from, next) =&gt; &#123; console.log(&quot;准备进入模板&quot;) next() &#125;, beforeRouteLeave: (to, from, next) =&gt; &#123; console.log(&quot;准备离开模板&quot;) next() &#125;&#125;; 编程式导航 this.$router.go(-1) 后退 this.$router.go(1) 前进 this.$router.push(‘/‘) 跳转的相应的路径 src/App.vue 123456789101112131415161718192021222324252627...&lt;template&gt;&lt;div&gt; &lt;button @click=&quot;goBack&quot;&gt;后退&lt;/button&gt; &lt;button @click=&quot;goNext&quot;&gt;前进&lt;/button&gt; &lt;button @click=&quot;goHome&quot;&gt;首页&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;...&lt;script&gt;export default &#123; name: &quot;App&quot;, methods:&#123; goBack()&#123; this.$router.go(-1) &#125;, goNext()&#123; this.$router.go(1) &#125;, goHome()&#123; this.$router.push(&apos;/&apos;) &#125; &#125;&#125;;&lt;/script&gt;... vuex安装vuex1cnpm i vuex --save –save 是因为vuex是要在生产环境调用的 在 src 下新建数据仓库 src/vuex/store.js src/vuex/store.js1234567891011121314151617181920212223242526//引入 vue 和 vueximport Vue from \"vue\"import Vuex from \"vuex\"//使用 vuexVue.use(Vuex)//stateconst state=&#123; count: 3&#125;//mutationsconst mutations = &#123; add(state)&#123; state.count ++ &#125;, cut(state)&#123; state.count -- &#125;&#125;//导出 state 和 mutationsexport default new Vuex.Store(&#123; state,mutations&#125;) 在 组件中使用src/component/count.vue1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt; &lt;div&gt;&#123;&#123; $store.state.count &#125;&#125;&lt;/div&gt; &lt;button @click=\"$store.commit('add')\"&gt;加&lt;/button&gt; &lt;button @click=\"$store.commit('cut')\"&gt;减&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import store from '@/vuex/store' export default &#123; data() &#123; return &#123; msg: 'Hello Vuex' &#125; &#125;, store &#125;&lt;/script&gt; 使用需先导入 import store from &#39;@/vuex/store&#39; 并写入到 export default 中 调用 数据 $store.state.count 方法 $store.commit(&#39;add&#39;) 注意括号中要加引号 简化state的调用src/component/count 方法一12345computed: &#123; count() &#123; return this.$store.state.count; &#125; &#125; computed属性可以在输出前，对data中的值进行改变，我们就利用这种特性把store.js中的state值赋值给我们模板中的data值。 方法二 注意这里 要带{ } 12345import &#123;mapState&#125; from 'vuex'computed:mapState(&#123; count:state=&gt;state.count &#125;) 方法三 这种方法最简单 12import &#123;mapState&#125; from 'vuex'computed:mapState([\"count\"]) 使用以上三种方法就可以在 template 中直接调用 了 mutations 修改状态 传参 store.js12345678const mutations=&#123; add(state,n)&#123; state.count+=n; &#125;, reduce(state)&#123; state.count--; &#125;&#125; count.vue1&lt;button @click=\"$store.commit('add',10)\"&gt;+&lt;/button&gt; 简化调用方式 count.vue12345678910import &#123; mapState,mapMutations &#125; from 'vuex';&lt;button @click=\"reduce\"&gt;-&lt;/button&gt;&lt;button @click=\"add(10)\"&gt;-&lt;/button&gt;&lt;script&gt; methods:mapMutations([ 'add','reduce']),&lt;/script&gt; getters过滤器src/vuex/store.js1234567const getters = &#123; count:(state)=&gt; state.count +=100&#125;export default new Vuex.Store(&#123; state,mutations,getters&#125;) src/component/count.vue1234computed: &#123; ...mapState([\"count\"]), ...mapGetters(['count'])&#125;, …为 es6 的扩展运算符 actions异步修改状态actions和之前讲的Mutations功能基本一样，不同点是，actions是异步的改变state状态，而Mutations是同步改变状态。 在store.js中声明actionsactions是可以调用Mutations里的方法的，我们还是继续在上节课的代码基础上进行学习，在actions里调用add和reduce两个方法。 1234567const actions =&#123; addAction(context)&#123; context.commit('add',10) &#125;, reduceAction(&#123;commit&#125;)&#123; commit('reduce') &#125; 在actions里写了两个方法addAction和reduceAction，在方法体里，我们都用commit调用了Mutations里边的方法。细心的小伙伴会发现这两个方法传递的参数也不一样。 context：上下文对象，这里你可以理解称store本身。{commit}：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。模板中的使用我们需要在count.vue模板中编写代码，让actions生效。我们先复制两个以前有的按钮，并改成我们的actions里的方法名，分别是：addAction和reduceAction。 1234&lt;p&gt; &lt;button @click=\"addAction\"&gt;+&lt;/button&gt; &lt;button @click=\"cutAction\"&gt;-&lt;/button&gt;&lt;/p&gt; 改造一下我们的methods方法，首先还是用扩展运算符把mapMutations和mapActions加入。 123456methods:&#123; ...mapMutations([ 'add','cut' ]), ...mapActions(['addAction','cutAction'])&#125;, 你还要记得用import把我们的mapActions引入才可以使用。 增加异步检验我们现在看的效果和我们用Mutations作的一模一样，肯定有的小伙伴会好奇，那actions有什么用，我们为了演示actions的异步功能，我们增加一个计时器（setTimeOut）延迟执行。在addAction里使用setTimeOut进行延迟执行。 12setTimeOut(()=&gt;&#123;context.commit(cut)&#125;,3000);console.log('我比reduce提前执行'); 我们可以看到在控制台先打印出了‘我比reduce提前执行’这句话。 modue模块组声明模块组：在vuex/store.js中声明模块组，我们还是用我们的const常量的方法声明模块组。代码如下： 123const moduleA=&#123; state,mutations,getters,actions&#125; 声明好后，我们需要修改原来 Vuex.Stroe里的值： 123export default new Vuex.Store(&#123; modules:&#123;a:moduleA&#125;&#125;) 在模板中使用现在我们要在模板中使用count状态，要用插值的形式写入。 1&lt;h3&gt;&#123;&#123;$store.state.a.count&#125;&#125;&lt;/h3&gt; 如果想用简单的方法引入，还是要在我们的计算属性中rutrun我们的状态。写法如下： 12345computed:&#123; count()&#123; return this.$store.state.a.count; &#125;&#125;,","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://bigma.cc/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://bigma.cc/tags/Vue/"},{"name":"VueCli","slug":"VueCli","permalink":"http://bigma.cc/tags/VueCli/"}]},{"title":"Laravel学习手记","slug":"Laravel学习手记","date":"2017-10-18T09:41:31.000Z","updated":"2023-09-06T14:03:24.659Z","comments":true,"path":"2017/10/18/Laravel学习手记/","link":"","permalink":"http://bigma.cc/2017/10/18/Laravel学习手记/","excerpt":"","text":"安装Laravel的Homestead开发环境请参考 Windows下搭建Laravel的Homestead开发环境 搭建本地环境1.下载安装 Study2.下载安装composer3.下载 最新版Laravel框架4.解压到网站目录 这里统一命名为laravel5.phpStudy 添加一个网站 laravel.app 路径指向你网站目录的 laravel\\public 下6.本地Host 文件添加一行 laravel.app 127.0.0.17.网站目录下的 laravel.env.example 文件复制改名 .env tips: windows下是无法创建改.env文件的，可以在vscode中创建，一定要创建啊，要不然打开会报500 错误 8.将以下内容添加到 composer.json 文件中 请参考 https://pkg.phpcomposer.com/ 这样就能使用中国的composer镜像了。 123456\"repositories\": &#123; \"packagist\": &#123; \"type\": \"composer\", \"url\": \"https://packagist.phpcomposer.com\" &#125;&#125; 9.在根目录执行 composer install 等待安装完成10.打开浏览器输入 laravel.app 如果出现 The only supported ciphers are AES-128-CBC and AES-256-CBC with the correct key lengths.的错误请在网站目录中执行以下命令1$ php artisan key:generate 11.在 Nginx 配置文件中加入 不加会导致请求api的时候404123location / &#123; try_files $uri $uri/ /index.php?$query_string;&#125; 数据库配置laravel/.env123456DB_CONNECTION=mysql #数据库类型DB_HOST=127.0.0.1 #数据库地址DB_PORT=3306 #端口DB_DATABASE=homestead #数据库名DB_USERNAME=homestead #数据库用户名DB_PASSWORD=secret #数据库密码 路由laravel\\routes\\web.php12//请求 /user 路径，访问 UserController 控制器中的 index 方法Route::get('/user', 'UserController@index'); 路由参数当然，有时需要在路由中捕获一些 URL 片段。例如，从 URL 中捕获用户的 ID，可以通过定义路由参数来执行此操作：123Route::get('user/&#123;id&#125;', function ($id) &#123; return 'User '.$id;&#125;); 也可以根据需要在路由中定义多个参数：123Route::get('posts/&#123;post&#125;/comments/&#123;comment&#125;', function ($postId, $commentId) &#123; //&#125;); 可选参数有时，你可能需要指定一个路由参数，但你希望这个参数是可选的。你可以在参数后面加上 ? 标记来实现，但前提是要确保路由的相应变量有默认值：1234567891011121314Route::get('user/&#123;name?&#125;', function ($name = null) &#123; return $name;&#125;);Route::get('user/&#123;name?&#125;', function ($name = 'John') &#123; return $name;&#125;);//需在控制器对应的方法中接收参数Route::get('/user/&#123;name?&#125;', 'UserController@index');//控制器中的方法public function index($name)&#123; some code...&#125; 路由组路由前缀可以用 prefix 方法为路由组中给定的 URL 增加前缀。例如，你可以为组中所有路由的 URI 加上 admin 前缀：12345Route::prefix('admin')-&gt;group(function () &#123; Route::get('users', function () &#123; // 匹配包含 \"/admin/users\" 的 URL &#125;);&#125;); 命名空间另一个常见用例是使用 namespace 方法将相同的 PHP 命名空间分配给路由组的中所有的控制器： 123Route::namespace('Admin')-&gt;group(function()&#123; Route::get('test', 'TController@test');&#125;); 在 App\\Http\\Controllers 新建一个文件夹 Admin 其下新建一个 TConroller.php TConroller.php 内容 1234567namespace App\\Http\\Controllers\\Admin;use App\\Http\\Controllers\\Controller;class TController extends Controller&#123; public function test()&#123; return \"命名空间路由测试\"; &#125;&#125; any如何页面是一个表单，既需要展示有需要post数据，可以使用 any1Route::any('admin/cate/edit/&#123;id&#125;', 'Admin\\CateController@update'); 在控制器中需要先判断是 get 还是 post 来执行不同的命令123456789101112public function update(Request $request, $id)&#123; if ($request-&gt;isMethod('get')) &#123; //判断 Method 方式 $row = CateModel::where(['id'=&gt;$id])-&gt;first()-&gt;toArray(); $cate = CateModel::tree(); return view('admin.cate.edit', ['row' =&gt; $row, 'cateRow'=&gt;$cate]); &#125; else &#123; $data = $request-&gt;except('_token'); CateModel::where(['id'=&gt;$id])-&gt;update($data); return redirect('admin/cate/list'); &#125;&#125; 请记住，默认情况下，RouteServiceProvider 会在命名空间组中引入你的路由文件，让你不用指定完整的 App\\Http\\Controllers 命名空间前缀就能注册控制器路由。因此，你只需要指定命名空间 App\\Http\\Controllers 之后的部分。 路由的其他使用方法 https://d.laravel-china.org/docs/5.5/routing 控制器1.控制器定义在 laravel\\app\\Http\\Controllers\\ 下2.使用命名空间，注意命名空间大小写，首字母大写 namespace App\\Http\\Controllers;3.定义的控制器类必须继承基础控制器 Controller4.必须先定义好路由新建 UserController.php 控制器文件 类名需与文件名保持一致123456789101112namespace App\\Http\\Controllers;use DB;class UserController extends Controller&#123; public function index()&#123; $sql = 'select * from user'; $rows = DB::select($sql); // DD($rows); // return \"Hello\"; return view('list', ['rows'=&gt;$rows]); &#125;&#125; 使用 view(‘list’, [‘rows’=&gt;$rows]) 调用 list 视图 通过数组传参使用 dd($rows) 来打印数据使用 DB来访问数据库控制方法 重定向重定向响应是类 Illuminate\\Http\\RedirectResponse 的实例, 包含了重定向用户到其他 URL 所需要的合适头信息。有很多方式生成 RedirectResponse 实例。最简单的方法是使用全局的 redirect 辅助函数：123456789Route::get('dashboard', function () &#123; return redirect('home/dashboard'); //重定向到本地 return redirect('/student'); //跨域重定向 return redirect('http://www.baidu.com'); //使用门面类调转 不推荐使用 return Redirect::to('/student');&#125;); 重定向到控制器12345return redirect()-&gt;action('HomeController@index');//传递参数return redirect()-&gt;action( 'UserController@profile', ['id' =&gt; 1]); 注意 使用 action 方法跳转到控制器对应的方法，需要事先在路由中注册该方法 response返回 json 数据1.必须使用 response() 函数2.必须使用 return 返回 123456789namespace App\\Http\\Controllers;class ResponseController extends Controller&#123; public function rj()&#123; $data = [\"name\" =&gt; \"laowang\" , \"age\" =&gt; 18]; return response()-&gt;json($data); &#125;&#125; 下载123public function down()&#123; return response()-&gt;download(\"D:/phpStudy/WWW/laravel/public/avatar.jpg\"); &#125; request$request-&gt;method() 获取当前 http 请求的方法$request-&gt;isMethod(“get”) 判断当前 http 请求的方法是否为 get$request-&gt;url() 返回当前的url 不包括参数 使用 $request-&gt;参数 可获取到参数的值$request-&gt;all() 获取post提交的表单数据 提交表单必须添加token type1234567891011121314151617$request-&gt;input(&quot;参数/表单元素名&quot;) 单独获取表单中元素名的值```php&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class RequestController extends Controller&#123; public function req(Request $request)&#123; dd($request-&gt;id); &#125; public function add(Request $request)&#123; dd($request-&gt;all()); &#125;&#125; Tips:1.使用 Request 类之前，必须 use 载入该类 use Illuminate\\Http\\Request;2.函数中，使用 Request 类名约束形式参数 使用命令行创建控制器在 laravel 目录下执行12345# 可显示 help 信息$ D:/phpStudy/php70n/php.exe artisan# 创建控制器$ D:/phpStudy/php70n/php.exe artisan make:controller PhotoController Restfull 风格控制器创建控制器12# 创建 restfull 风格控制器 （将PHP.exe加入环境变量则可以直接使用 php artisan）$ php artisan make:controller TestController --resource 使用专用路由1Route::resource('photo','PhotoController'); 使用一下命令查看路由表12345678910111213$ php artisan route:list+--------+-----------+--------------------+---------------+----------------------------------------------+--------------+| Domain | Method | URI | Name | Action | Middleware |+--------+-----------+--------------------+---------------+----------------------------------------------+--------------+| | GET|HEAD | photo | photo.index | App\\Http\\Controllers\\PhotoController@index | web || | POST | photo | photo.store | App\\Http\\Controllers\\PhotoController@store | web || | GET|HEAD | photo/create | photo.create | App\\Http\\Controllers\\PhotoController@create | web || | GET|HEAD | photo/&#123;photo&#125; | photo.show | App\\Http\\Controllers\\PhotoController@show | web || | PUT|PATCH | photo/&#123;photo&#125; | photo.update | App\\Http\\Controllers\\PhotoController@update | web || | DELETE | photo/&#123;photo&#125; | photo.destroy | App\\Http\\Controllers\\PhotoController@destroy | web || | GET|HEAD | photo/&#123;photo&#125;/edit | photo.edit | App\\Http\\Controllers\\PhotoController@edit | web |+--------+-----------+--------------------+---------------+----------------------------------------------+--------------+ 视图视图新建在 resources/views/ 目录下，为PHP文件使用 view(“视图文件名”, [“参数名”=&gt; “参数值”]) 调用视图文件。多级目录使用 folder.folder.viewname 的形式123456789namespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class ShowController extends Controller&#123; public function show()&#123; return view('test.show', ['name'=&gt;'Hello']); &#125; &#125; 使用DB调用数据先配置好数据库连接新建 list.php 视图文件 通过 echo $rows 显示数据12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;?php foreach($rows as $row)&#123; ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $row-&gt;id; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $row-&gt;user; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $row-&gt;age; ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php &#125; ?&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 控制器文件12345678910111213&lt;?phpnamespace App\\Http\\Controllers;use DB;class UserController extends Controller&#123; public function index()&#123; $sql = 'select * from user'; $rows = DB::select($sql); // DD($rows); // return \"Hello\"; return view('list', ['rows'=&gt;$rows]); &#125;&#125; blade模版在 resources/views/ 目录下新建 viewname.blade.php 的 blade 模版变量输出```123**执行函数**可执行 PHP 和 Laravel 函数``` &#123;&#123;print_r($name)&#125;&#125; 三元表达式? $name : 'Default'&#125;&#125; ```12345678910111213blade 模版的三元表达式&#123;&#123;$name or &apos;Default&apos;&#125;&#125;**输出原始数据（不转义HTML）**&#123;!!$name!!&#125;**循环语句**```php@for ($i = 0; $i &lt; 10; $i++) 目前的值为 &#123;&#123; $i &#125;&#125;@endfor@foreach ($users as $user) &lt;p&gt;此用户为 &#123;&#123; $user-&gt;id &#125;&#125;&lt;/p&gt;@endforeach https://d.laravel-china.org/docs/5.5/blade#loops if语句1234567@if (count($records) === 1) 我有一条记录！@elseif (count($records) &gt; 1) 我有多条记录！@else 我没有任何记录！@endif https://d.laravel-china.org/docs/5.5/blade#if-statements 区块划分语句123456789101112//创建 top 区块 并立即显示@section(\"top\")somecode@show//只创建 top 区块@section(\"top\")somecode@endsection//引用 top 区块@yield(\"top\") 继承模版1@extends(\"template.master\") component 组件使用定义组件新建一个 component1.blade.php 文件12345&lt;div class='component'&gt; &lt;!-- $title，$content 变量实际上就是预定义的插槽 --&gt; &lt;div class='title'&gt;&#123;&#123; $title &#125;&#125;&lt;/div&gt; &lt;div class='content'&gt;&#123;&#123; $content &#125;&#125;&lt;/div&gt;&lt;/div&gt; 使用组件@slot 传递变量123456789@component('blade.component1') //括号中为组件的路径 @slot('title') 组件标题 //为组件中的 &#123;&#123;$title&#125;&#125; 传值 @endslot @slot('content') 组件内容 @endslot@endcomponent 渲染JSON内容1var app = @json($array); 输出存在的变量1234//有时候你想要输出一个变量，但是不确定该变量是否被设置，我们可以通过如下 PHP 代码：&#123; isset($name) ? $name : 'Default' &#125;&#125;// 除了使用三元运算符，Blade 还提供了更简单的方式： 如果 $name 变量存在，其值将会显示，否则将会显示 Default。&#123;&#123; $name or 'Default' &#125;&#125; Blade &amp; JavaScript 框架Vue也使用双花括号，所以使用 @ 符号来告诉 Blade 渲染引擎该表达式应该保持原生格式不作改动，使Vue能正确渲染123456789&lt;h1&gt;Laravel&lt;/h1&gt;Hello, @&#123;&#123; name &#125;&#125;.//使用 verbatim 此块中的代码不会被blade渲染。@verbatim &lt;div class=\"container\"&gt; Hello, &#123;&#123; name &#125;&#125;. &lt;/div&gt;@endverbatim 认证指令123456789101112131415161718//@auth 和 @guest 指令可用于快速判断当前用户是否登录：@auth // 用户已登录...@endauth@guest // 用户未登录...@endguest//如果需要的话，你也可以在使用 @auth 和 @guest 的时候指定登录用户类型：@auth('admin') // The user is authenticated...@endauth@guest('admin') // The user is not authenticated...@endguest 注释 Blade 还允许你在视图中定义注释，然而，不同于 HTML 注释，Blade 注释并不会包含到 HTML 中被返回：1&#123;&#123;-- This comment will not be present in the rendered HTML --&#125;&#125; PHP 在一些场景中，嵌入 PHP 代码到视图中很有用，你可以使用 @php 指令在模板中执行一段原生 PHP 代码：123@php //@endphp 模型模型用来对数据库进行操作。创建 Model1$ php artisan make:model Models/UserModel UserModel 将创建在 laravel/app/Models 目录下Tips namespace 每个目录名大写 使用基础模型类 use Illuminate\\Database\\Eloquent\\Model; 需要使用成员属性 $table 指定表名 如果该表的主键非 id ，需要使用 $primaryKey 指定该表的主键 1234567//UserModel.phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class UserModel extends Model&#123; protected $table=\"admin\";&#125; 查询数据新建控制器 UserController.php123456789101112131415161718192021222324252627namespace App\\Http\\Controllers;use App\\Models\\UserModel;class UserController extends Controller&#123; public function select()&#123; //查询所有数据 $row = UserModel::all(); dd($row); //使用 get()-&gt;toArray() 将查询的数据集转换成数组 $row = UserModel::get() -&gt;toArray(); dd($row); //where 进行条件查询 first() 表示取出第一天数据 $user = UserModel::where('user', '老王')-&gt;first(); dd($user); //使用 $user-&gt;id 取出成员id dd($user-&gt;id); //使用 value 函数直接取出值 $user = UserModel::where('user', '老王')-&gt;value('id'); dd($user); //选择字段取值 $user = UserModel::where('user', '老王')-&gt;select('user', 'age')-&gt;get()-&gt;toArray(); dd($user); &#125;&#125; 插入数据Tips1.Laravel 默认的插入方式需要表中有 updated_at 和 created_at 字段（timestamp类型） 用来保存更新和创建时间。关闭方法为在 Model 中添加 $timestamps 12.使用数组形式插入数据需要在 Model 中定义哪些字段可以插入 ```php protected $fillable = [&apos;user&apos;, &apos;age&apos;]; 1234567891011121314151617181920212223public function insert()&#123; //单条插入 $user = new UserModel(); $user-&gt;user = \"老马\"; $user-&gt;age = \"16\"; $user-&gt;save(); dd($user-&gt;id); //数组插入 $user-&gt;fill(['user'=&gt;\"小马\", \"age\" =&gt; 16]); $user-&gt;save(); //一次插入多条数据 UserModel::insert([ ['user'=&gt;\"小马2\", \"age\" =&gt; 16], ['user'=&gt;\"小马3\", \"age\" =&gt; 16], ['user'=&gt;\"小马4\", \"age\" =&gt; 16], ['user'=&gt;\"小马5\", \"age\" =&gt; 16], ['user'=&gt;\"小马6\", \"age\" =&gt; 16] ]); &#125; 更新数据123456789public function update()&#123; //更新数据 $user = UserModel::where(['id'=&gt;'1'])-&gt;first(); $user-&gt;user = \"老李\"; $user-&gt;save(); //更新形式2 UserModel::where(['id'=&gt;'1'])-&gt;update(['user'=&gt;'老毛桃']); &#125; 删除数据123public function delete()&#123; UserModel::where(['id'=&gt;'2'])-&gt;delete(); &#125; 一对一查询12345678910111213//ArticleModelpublic function Cate()&#123; //id 表示分类表中的 id 字段 ，cate 表示文章表中的 cate 字段 //使用文章表中的 cate 字段 查出 对应分类表id 字段的数据 return $this-&gt;hasOne('App\\Models\\Admin\\CateModel', 'id', 'cate');&#125;//ArticleModelpublic function getlist() &#123; $rows = ArticleModel::get(); //dd($row[0]-&gt;Cate-&gt;name);//取出name值 return view('admin.list', ['rows' =&gt; $rows]); &#125; View 模版12345678@foreach($rows as $row) &lt;tr&gt; &lt;th scope=\"row\"&gt;&#123;&#123;$row-&gt;id&#125;&#125;&lt;/th&gt; &lt;td&gt;&#123;&#123;$row-&gt;title&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$row-&gt;Cate-&gt;name&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"/admin/article/edit/&#123;&#123;$row['id']&#125;&#125;\"&gt;&lt;span class=\"glyphicon glyphicon-edit\" aria-hidden=\"true\"&gt;&lt;/span&gt;&lt;/a&gt; | &lt;span class=\"glyphicon glyphicon-remove-sign\" aria-hidden=\"true\"&gt;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt;@endforeach 一对多查询1234567891011121314//CateModelpublic function Articles()&#123; //在分类模型中 使用一对多 通过传入的分类 id 匹配 ArticleModel 的 cate 字段 获取多篇文章 return $this-&gt;hasMany('App\\Models\\Admin\\ArticleModel', 'cate', 'id'); &#125;//CateControllerpublic function show($id) &#123; //使用 分类 查出多条文章 一对多查询 $cate = CateModel::find($id) -&gt; Articles() -&gt;get() -&gt; toArray(); dd($cate); &#125; 基本分页1234567//$rows = ArticleModel::get();//基本分页$rows = ArticleModel::simplePaginate(2);//带页码分页$rows = ArticleModel::Paginate(2);//模版 &#123;!! $rows-&gt;render()!!&#125; 静态资源在 blade 模版中使用 可引用 public 目录下的文件。123456使用 Hash::check(&apos;明文&apos;, &apos;密文&apos;);# Session#### 一次性Session```php$request-&gt;session()-&gt;flash(&apos;message&apos;, &apos;账号密码错误&apos;); Hash1234567使用 Hash 需要先引用use Illuminate\\Support\\Facades\\Hash;//加密Hash::make($password)]//对比Hash::check($password, $user-&gt;password)","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://bigma.cc/tags/laravel/"},{"name":"php","slug":"php","permalink":"http://bigma.cc/tags/php/"}]},{"title":"Hexo 踩坑日志","slug":"Hexo踩坑日志","date":"2017-08-09T01:19:32.000Z","updated":"2023-09-06T14:03:24.659Z","comments":true,"path":"2017/08/09/Hexo踩坑日志/","link":"","permalink":"http://bigma.cc/2017/08/09/Hexo踩坑日志/","excerpt":"这里记录在使用Hexo中踩到的坑。","text":"这里记录在使用Hexo中踩到的坑。 1今天在发布文章的时候发现发不出来，明明在source_posts里有md文件，hexo g 生成后，首页却不显示。仔细翻阅发布时显示的日志发现一处错误123ERROR Process failed: _posts/Homestead.mdYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 7: 原来在 tags 的冒号后边需要有空格才行，没有空格就会出错。加上空格，发布成功！ 212345$ hexo gINFO Start processingFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: Error: Unable to call `asset`, which is undefined or falsey 我在文章中找到了 一个用双大括号括着的 asset(&quot;css.css&quot;) 去掉之后就好了。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://bigma.cc/tags/Hexo/"}]},{"title":"Windows下搭建Laravel的Homestead开发环境","slug":"Homestead","date":"2017-08-08T06:35:32.000Z","updated":"2023-09-06T14:03:24.659Z","comments":true,"path":"2017/08/08/Homestead/","link":"","permalink":"http://bigma.cc/2017/08/08/Homestead/","excerpt":"Laravel Homestead 是一个官方预封装的 Vagrant box，它为你提供了一个完美的开发环境，你无需在本地安装 PHP ，web 服务器，或其他服务软件。","text":"Laravel Homestead 是一个官方预封装的 Vagrant box，它为你提供了一个完美的开发环境，你无需在本地安装 PHP ，web 服务器，或其他服务软件。并且不用担心系统被搞乱！ Vagrant box 是完全一次性的。如果有什么地方出错了，你也可以在几分钟内销毁并重建 box ！–以上内容摘抄自官方文档 首先下载和安装VirtualBox和Vagrantgit bash https://git-for-windows.github.io/ VirtualBox https://www.virtualbox.org/wiki/Downloads Vagrant 请下载对应版本 windows就下windows版的 https://www.vagrantup.com/downloads.html 下载完 Vagrant 需要重启，重启完成后用 Git Bash 验证下 Vagrant是否安装成功 12$ Vagrant -vVagrant 1.9.7 添加 homestead.box添加laravel/homestead 到 varant box其实就是下载一个virtualbox.box的虚拟机文件 1Gb左右大小，请挂好你的VPN 执行以下命令1$ vagrant box add laravel/homestead 会有三个选项让你选择。这里我们用的varant box 就选21231) parallels2) virtualbox3) vmware_desktop 这样就开始下载了，耐心等待吧。如果觉得下载太慢，复制出来其中的virtualbox.box 地址 用 Idm 下载。然后Ctrl + C 打断下载。在D盘或是别的盘建立一个 homestead 文件夹，把.box文件拷进去。在 Git Bash 输入1$ vagrant box add laravel/homestead file:///D:/homestead/virtualbox.box 后面的 file:///D:/homestead/virtualbox.box 是路径。 都搞顶后执行以下命令检查是否添加成功12$ vagrant box listlaravel/homestead (virtualbox, 3.0.0) 配置homestead在D盘的 homestead 文件夹下执行123git clone https://github.com/laravel/homestead.git homesteadcd homesteadbash init.sh 然后我们在 D：/homestead/homestead/ 下会找到 Homestead.yaml 文件这个就是 配置homestead 的配置文件 虚拟机配置配置IP 内存和CPU核心数，默认就好123ip: \"192.168.10.10\"memory: 2048cpus: 1 本地磁盘的映射map为本地PC的路径to为虚拟机的路径123folders: - map: D:/homestead/Code to: /home/vagrant/Code 站点配置map 为域名，当然这里我们不用去注册这个域名，只要在本地Hosts文件里映射下就好了。windows 下 打开 C:\\Windows\\System32\\drivers\\etc\\ 将hosts 复制到桌面，打开添加一行192.168.10.10 windy.app 保存，覆盖回去就好了。 to 为站点在虚拟机上的路径这里要注意，如果你在Code下使用laravel new blog 新建了一个 blog 的laravel项目那么站点路径应该如下 123sites: - map: windy.app to: /home/vagrant/Code/blog/public 启动配置完成之后在该目录下 也就是 D：/homestead/homestead/ 执行一下命令启动虚拟机1$ vagrant up 连接SSH1$ vagrant ssh 默认启动一个mysql数据库，默认的账号密码为用户名：homestead密码：secret命令行登陆：1$ mysql -uhomestead -psecret","categories":[],"tags":[{"name":"VirtualBox","slug":"VirtualBox","permalink":"http://bigma.cc/tags/VirtualBox/"},{"name":"Homestead","slug":"Homestead","permalink":"http://bigma.cc/tags/Homestead/"},{"name":"laravel","slug":"laravel","permalink":"http://bigma.cc/tags/laravel/"}]},{"title":"使用码云的WebHooks实现网站的自动部署","slug":"webhooks_for_gitoschina","date":"2017-07-17T07:07:57.000Z","updated":"2023-09-06T14:03:24.664Z","comments":true,"path":"2017/07/17/webhooks_for_gitoschina/","link":"","permalink":"http://bigma.cc/2017/07/17/webhooks_for_gitoschina/","excerpt":"码云上提供了一个WebHooks功能（其实github也有），原理就是在本地push的时候码云的WebHooks会向远程服务器进行post请求，这个post还可以带上一个密码，防止被恶意post。","text":"码云上提供了一个WebHooks功能（其实github也有），原理就是在本地push的时候码云的WebHooks会向远程服务器进行post请求，这个post还可以带上一个密码，防止被恶意post。 另外WebHooks还支持push, tag push, lssue 等共5种触发方式。 我想实现的是本地 tag push之后 服务器的本地仓库执行pull操作，从而实现网站的自动部署。使用tag push的原因是我并不想每次push都进行部署。 下面就一步一步来实现这个过程。 1.首先在码云上创建一个项目，项目中只放 README.md，因为我们只是先实验下这样就够了。 2.将这个项目clone到本地及服务器 3.在服务器端创建一个pull.php文件，放到一个可以访问的网站目录，方便WebHooks进行post操作。php这里我们使用了shell_exec方法。在访问到该php文件后会执行pull.sh脚本。 shell_exec 默认是关闭的，要从php.ini中开启1vim /usr/local/php/etc/php.ini 搜索disable_function 将其中的 exec 和 shell_exec 删除。 这里尽量使用绝对路径，我使用了PHP的shell_exec函数，当然还可以使用exec system等函数。 pull.php1234&lt;?php$output = shell_exec(\"/usr/bin/sudo /root/pull.sh\");echo $output;?&gt; pull.sh 123#!/bin/shcd /data/wwwroot/bigma.cc #进入到需要git pull的网站目录git pull #执行pull命令 创建两个脚本后，要对脚本执行 chmod +x filename 为其添加执行的权限。 4.配置git公钥，公钥可以让你在服务器的本地仓库执行git pull的时候不需要输入密码。具体如何配置请参考配置公钥 5.为服务器端的PHP添加执行shell脚本的权限 12345vi /etc/sudoers#注释掉下面一行#Defaults requiretty#末尾加入 www为http 用户 此处也可指定某个脚本无需密码www ALL=(ALL) NOPASSWD: ALL 6.使用 su www 切换到 www 用户执行 php pull.php 测试能否成功执行脚本，执行成功将返回 git pull的回馈信息。 7.在码云的 WebHooks 中填入 pull.php 的url。本地执行git pull 看看网站目录是否自动更新了。 至此，使用 WebHooks 自动部署网站已配置完成。之后可以为pull.php加上密码验证提升安全性。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://bigma.cc/tags/git/"},{"name":"webhooks","slug":"webhooks","permalink":"http://bigma.cc/tags/webhooks/"}]},{"title":"gulp学习手记","slug":"gulp学习手记","date":"2017-06-30T14:23:54.000Z","updated":"2023-09-06T14:03:24.662Z","comments":true,"path":"2017/06/30/gulp学习手记/","link":"","permalink":"http://bigma.cc/2017/06/30/gulp学习手记/","excerpt":"","text":"创建目录 初始化1npm init -y 注意，package.json 中的name 不能为 gulp 安装 gulp12npm install gulp-cli -gnpm install gulp -D //-D相当于 --save-dev 创建配置文件1touch gulpfile.js 安装所需要的插件12345678910111213141516171819npm install gulp-concat gulp-uglify gulp-rename gulp-htmlmin del copy --save-dev npm install gulp-jshint --save-dev //js脚本检查npm install gulp-uglify --save-dev //js压缩插件npm install gulp-concat --save-dev //js合并插件npm install gulp-order --save-dev //js合并顺序控制插件npm install gulp-cssnano --save-dev //css压缩插件npm install gulp-sass --save-dev //编译sassnpm install gulp-less --save-dev //less文件编译 npm install gulp-htmlmin --save-dev //html压缩插件npm install gulp-html-replace --save-dev //html文件对合并文件后的替换处理插件npm install gulp-imagemin --save-dev //图片压缩插件npm install del --save-dev //文件删除模块npm install copy --save-dev //文件拷贝模块 插件配置插件配置之前要先在 gulpfile.js 中 用 require 引入1plugin = require(&apos;gulp-plugin&apos;); 插件配置del 清除旧部署文件1234gulp.task(&apos;clean&apos;, function (cb) &#123; del([&apos;dest/*&apos;]); cb();&#125;); copy 拷贝 图标、字体、第三方已压缩文件1234gulp.task(&apos;copy&apos;, function (cb) &#123; copy(&apos;favicon.ico&apos;, &apos;dest/&apos;); cb();&#125;); uglify concat 压缩 js 文件（包括合并操作， 多个js文件压缩成一个文件） 12345678910gulp.task('uglifyjs', function () &#123; // 1. 找到文件 gulp.src(['datas/*.js']) // 2. 压缩文件 .pipe(uglify()) // 3. 合并成一个文件 .pipe(concat('datas.js')) // 4. 另存压缩后的文件 .pipe(gulp.dest('dest/datas/'));&#125;); less/sass cssnano 编译并压缩 css 文件12345678910gulp.task(&apos;cssmin&apos;, function () &#123; // 1. 找到文件 如果为less sass请注意文件名 gulp.src(&apos;css/main.css&apos;) // 2. 编译css .pipe(less()) // 3. 压缩文件 .pipe(cssnano()) // 4. 另存为压缩文件 .pipe(gulp.dest(&apos;dest/css/&apos;))&#125;); htmlmin html压缩插件 html-replace html外链替换插件 在html 中替换 调用的 js代码，以及压缩html（例如， a.html 调用了 a.js b.js， 然后 a.js b.js在第3步或第5步被合并成 c.min.js ; 这部分作用就是自动将a.html中改成调用 c.min.js ）。 12345678910111213141516171819202122gulp.task(&apos;htmlmin&apos;, function () &#123; var options = &#123; collapseWhitespace: true, //压缩HTML //省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt; collapseBooleanAttributes: false, //删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除&lt;script&gt;的type=&quot;text/javascript&quot; removeScriptTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot; removeStyleLinkTypeAttributes: true, minifyJS: true, //压缩页面JS minifyCSS: true //压缩页面CSS &#125;; gulp.src(&apos;index.html&apos;) .pipe(htmlReplace(&#123; &apos;datasjs&apos;: &apos;datas/datas.js&apos;, &apos;mainjs&apos;: &apos;js/main.js&apos; &#125;)) .pipe(htmlmin(options)) .pipe(gulp.dest(&apos;dest/&apos;));&#125;); 将多个js或css 替换成单个 html 替换前12345678910&lt;!-- build:css --&gt;&lt;link rel=\"stylesheet\" href=\"css/common.css\"&gt;&lt;link rel=\"stylesheet\" href=\"css/floatlayer.css\"&gt;&lt;!-- endbuild --&gt;&lt;!-- build:js --&gt;&lt;script src=\"js/base.js\"&gt;&lt;/script&gt;&lt;script src=\"js/app_boot.js\"&gt;&lt;/script&gt;&lt;script src=\"js/app_loader.js\"&gt;&lt;/script&gt;&lt;!-- endbuild --&gt; gulpfile.js12345gulp.src(&apos;src/index.html&apos;).pipe(htmlreplace(&#123;&apos;css&apos;: &apos;css/main.css&apos;,&apos;js&apos;: &apos;js/main.js&apos;&#125;)) html 替换后123&lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot;&gt;&lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt; imagemin 压缩图片12345678910gulp.task(&apos;imagemin&apos;, function () &#123; // 1. 找到图片 gulp.src(&apos;images/**/*.&#123;png,jpg,jpeg,gif,webp,svg&#125;&apos;) // 2. 压缩图片 .pipe(imagemin(&#123; progressive: true &#125;)) // 3. 另存图片 .pipe(gulp.dest(&apos;dest/images&apos;))&#125;); gulp-order js合并顺序控制 123456789101112gulp .src(&quot;**/*.coffee&quot;) .pipe(coffee()) .pipe(gulp.src(&quot;**/*.js&quot;)) // gulp.src passes through input .pipe(order([ &quot;vendor/js1.js&quot;, &quot;vendor/**/*.js&quot;, &quot;app/coffee1.js&quot;, &quot;app/**/*.js&quot; ])) .pipe(concat(&quot;all.js&quot;)) .pipe(gulp.dest(&quot;dist&quot;)); 浏览器同步刷新1npm install browser-sync --save -dev 配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var gulp = require(&apos;gulp&apos;); //获取gulpvar browsersync = require(&apos;browser-sync&apos;).create();//获取browsersync//删除dist目录下文件var del=require(&apos;del&apos;);gulp.task(&apos;clean&apos;,function(cb)&#123; return del([&apos;dist/*&apos;],cb);&#125;)//操作js文件var uglify = require(&apos;gulp-uglify&apos;); //js压缩插件var concat = require(&apos;gulp-concat&apos;); //js合并插件gulp.task(&apos;scripts&apos;, function() &#123; gulp.src(&apos;js/*.js&apos;) //需要操作的源文件 .pipe(uglify()) //压缩js文件 .pipe(concat(&apos;app.js&apos;)) //把js文件合并成app.js文件 .pipe(gulp.dest(&apos;dist/js&apos;)) //把操作好的文件放到dist/js目录下 .pipe(browsersync.stream()); //文件有更新自动执行&#125;);//操作css文件var cssnano = require(&apos;gulp-cssnano&apos;); //css压缩插件var less=require(&apos;gulp-less&apos;) //less文件编译gulp.task(&apos;style&apos;, function() &#123; gulp.src(&apos;style/*.css&apos;) .pipe(less()) //编译less文件 .pipe(cssnano()) //css压缩 .pipe(gulp.dest(&apos;dist/style&apos;)) .pipe(browsersync.stream());&#125;);var imagemin = require(&apos;gulp-imagemin&apos;); //图片压缩插件gulp.task(&apos;image&apos;, function() &#123; gulp.src(&apos;images/*.&#123;png,jpg,jpeg,gif&#125;&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;dist/images&apos;)) .pipe(browsersync.stream());&#125;);var htmlmin = require(&apos;gulp-htmlmin&apos;); //html压缩插件gulp.task(&apos;html&apos;, function() &#123; gulp.src(&apos;*.html&apos;) .pipe(htmlmin(&#123; collapseWhitespace: true, //压缩html collapseBooleanAttributes: true, //省略布尔属性的值 removeComments: true, //清除html注释 removeEmptyAttributes: true, //删除所有空格作为属性值 removeScriptTypeAttributes: true, //删除type=text/javascript removeStyleLinkTypeAttributes: true, //删除type=text/css minifyJS:true, //压缩页面js minifyCSS:true //压缩页面css &#125;)) .pipe(gulp.dest(&apos;dist&apos;)) .pipe(browsersync.stream());&#125;);gulp.task(&apos;serve&apos;, [&apos;clean&apos;], function() &#123; gulp.start(&apos;scripts&apos;,&apos;style&apos;,&apos;image&apos;,&apos;html&apos;); browsersync.init(&#123; port: 2016, server: &#123; baseDir: [&apos;dist&apos;] &#125; &#125;); gulp.watch(&apos;js/*.js&apos;, [&apos;scripts&apos;]); //监控文件变化，自动更新 gulp.watch(&apos;style/*.css&apos;, [&apos;style&apos;]); gulp.watch(&apos;images/*.*&apos;, [&apos;image&apos;]); gulp.watch(&apos;*.html&apos;, [&apos;html&apos;]);&#125;);gulp.task(&apos;default&apos;,[&apos;serve&apos;]);","categories":[],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://bigma.cc/tags/gulp/"}]},{"title":"webpack学习手记","slug":"webpack学习手记","date":"2017-06-28T14:22:11.000Z","updated":"2023-09-06T14:03:24.664Z","comments":true,"path":"2017/06/28/webpack学习手记/","link":"","permalink":"http://bigma.cc/2017/06/28/webpack学习手记/","excerpt":"","text":"初始化1npm init -y 生成package.json 文件 注意package.json 中的name 不能为webpack 否则无法安装webpack 安装1npm install webpack --save-dev 使用1node_modules/.bin/webpack app.js build/index.js 将app.js 打包成build/index.js 快捷编译在 package.json 的 scripts 中加入 \"webpack\" ```1234567891011就可以使用 ```npm run build``` 命令进行编译了。使用 ```npm run ``` 可以查看当前可用的命令。安装 ```html-webpack-plugin``` 可以自动生成一个html并自动引用webpack生产的js文件## 自动刷新```javascriptnpm install webpack-dev-server --save-dev 在package.json 得 script中加入以下脚本12\"start\": \"webpack-dev-server --env development\",\"build\": \"webpack --env production\" 使用 npm run start 可开启一个本地的服务 127.0.0.1:8080 监视文件修改并自动刷新 指定WDS的端口webpack.config.js 123456module.exports = &#123; devServer: &#123; port: 8081 //端口 &#125;, ...&#125; eslint代码规范化 package.json安装1npm install eslint --save-dev package.json - scripts1\"lintjs\": \"eslint app/ webpack.*.js --cache\" .eslintrc.js 配置文件123456789101112131415161718192021module.exports = &#123; env: &#123; browser: true, commonjs: true, es6: true, node: true, &#125;, extends: 'eslint:recommended', parserOptions: &#123; sourceType: 'module', &#125;, rules: &#123; 'comma-dangle': ['error', 'always-multiline'], indent: ['error', 2], 'linebreak-style': ['error', 'unix'], quotes: ['error', 'single'], semi: ['error', 'always'], 'no-unused-vars': ['warn'], 'no-console': 0, &#125;,&#125;; 自动修正1npm run lintjs -- --fix eslint代码规范化 webpack.config.js安装1npm install eslint-loader --save-dev 配置 webpack.config.js - module.exports 12345678910111213module:&#123; rules:[ &#123; test: /\\.js$/, enforce: 'pre', loader: 'eslint-loader', options: &#123; emitWarning: true, &#125;, &#125;, ], &#125;, 将错误抛到浏览器中 webpack.config.js - module.exports - devServer1234overlay: &#123; errors: true, warnings: true, &#125;, CSS 相关配置CSS-loader处理css中的 @import 和 url()如果 @import 加载的是外部文件则不会处理 style-loader处理 style 标签 安装1npm install css-loader style-loader --save-dev 配置webpack.config.js - module.exports - module - rules 12345678910111213&#123; test: /\\.css$/, exclude: /node_modules/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; modules: true, &#125;, &#125;, ],&#125;, 将css导入到入口文件1import &apos;./style.css&apos;; css作用域启用css-loader 的 modules 后，可将同样名称的css转为类似hash的得命名以避免冲突 代码可参考 https://github.com/ParryQiu/DevOpenClub-Tech-Webpack2/tree/master/011/app css js 分离因为js在页尾加载，css如果嵌入到js里，会导致页面闪屏，所以要进行分离 安装1npm install extract-text-webpack-plugin --save-dev 配置webpack.config.js123456const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);const plugin = new ExtractTextPlugin(&#123; filename: &apos;[name].css&apos;, ignoreOrder: true,&#125;); webpack.config.js - module.exports - module - rules 12345678910111213&#123; test: /\\.css$/, exclude: /node_modules/, use: plugin.extract(&#123; use: &#123; loader: &apos;css-loader&apos;, options: &#123; modules: true, &#125;, &#125;, fallback : &apos;style-loader&apos;, &#125;),&#125;, loaderloader顺序从右到左，从下到上Enforcing Order 强制条件加载顺序 loader配置webpack.config.js - module.exports - module - rules 一个loader12loader: &apos;loader-name&apos;,options: &#123;&#125;, 多个loader12345678use: &#123;loader: &apos;loader-name&apos;,options: &#123;&#125;,&#125;,&#123;loader: &apos;loader-name&apos;,options: &#123;&#125;,&#125;,... 文件压缩检测文件大小webpack.config.js - module.exports 12345performance: &#123; hints: &apos;warning&apos;, // &apos;error&apos; maxEntrypointSize: 100000, // bytes 文本资源超过100kb抛出警告 maxAssetSize: 450000, // bytes 图像资源超过450kb抛出警告&#125;, 使用插件压缩 babili-webpack-plugin安装1npm install babili-webpack-plugin --save-dev 配置webpack.config.js1const BabiliPlugin = require(&apos;babili-webpack-plugin&apos;); webpack.config.js - module.exports - plugins1new BabiliPlugin(), SourceMaps 便于断点调试js配置webpack.config.js - module.exports1devtool: &apos;source-map&apos;, 更多devtool https://webpack.js.org/configuration/devtool/#devtool 分离打包项目代码与组件代码配置12345678910111213const webpack = require('webpack');// module.exportsentry: &#123; app: PATHS.app, vendor: ['react'], &#125;, // pluginsnew webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor',&#125;), 使用可视化图表进行统计分析打包过程pakeage.json - scripts1&quot;stats&quot;: &quot;webpack --env production --profile --json &gt; stats.json&quot; 将目录下生成的stats.json 上传到 webpack.github.io/analyse/ 配置多页面编译module.exports12345entry: &#123; index: &apos;./app/index.js&apos;, about: &apos;./app/about.js&apos;, vendor: [&apos;react&apos;], &#125;, HMR Hot Module package.json - scripts 1&quot;hmr&quot;: &quot;webpack-dev-server&quot; webpack.config.js - module.exports - devServer 1hotOnly: true, //HMR webpack.config.js - module.exports - plugins 1new webpack.HotModuleReplacementPlugin(), //HMR --hot HTR interfase 1234567if(module.hot) &#123; // Capture hot update module.hot.accept(&apos;./library&apos;, () =&gt; &#123; console.log(&apos;Accepting the updated library module!&apos;); Library.log(); &#125;);&#125;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://bigma.cc/tags/webpack/"},{"name":"前端打包工具","slug":"前端打包工具","permalink":"http://bigma.cc/tags/前端打包工具/"}]},{"title":"Phaser学习手记","slug":"Phaser学习手记","date":"2017-05-27T14:25:32.000Z","updated":"2023-09-06T14:03:24.660Z","comments":true,"path":"2017/05/27/Phaser学习手记/","link":"","permalink":"http://bigma.cc/2017/05/27/Phaser学习手记/","excerpt":"","text":"实例化1new Phaser.Game(width, height, renderer, parent, state, transparent, antialias, physicsConfig); 例子：1var game = new Phaser.Game(300, 400, Phaser.AUTO, container); 12345678width //游戏宽度height //游戏高度renderer //游戏渲染方式 Phaser.CANVAS/Phaser.WEBGL/Phaser.AUTOparent//游戏的容器 DOM元素或IDstate //游戏默认场景transparent //画布元素是否透明antialias //是否开启抗锯齿physicsConfig //物理引擎配置 Game对象属性暂停游戏1game.Paused = true 运行游戏1game.Paused = false 其他属性 12345678910game.add; //是对游戏对象工厂的一个引用game.camera; //是游戏中摄像机对象的引用game.input; //是游戏中的用户交互事件对象的引用game.load; //是游戏资源加载模块的引用game.scale; //是游戏缩放模块的引用game.sound; //是游戏声音模块的引用game.stage; //是游戏舞台对象的引用game.particles; //是游戏粒子系统的引用game.physics; //是游戏物理系统的引用game.state; //是游戏场景管理对象的引用 State 场景创建场景对象 Phaser.State 的两种形式 对象形式12345&#123; init: function()&#123;&#125;, preload: function()&#123;&#125;, ....&#125; 函数形式12345function()&#123; this.init = function()&#123;&#125;, this.preload = funtion()&#123;&#125;, ...&#125; preload, create, update, render 至少要存在一个 12345init(); //场景初始化代码preload(); //加载游戏资源create(); //创建游戏显示对象或注册时间等update(); //游戏每一帧都会调用render(); //游戏每一个渲染周期都会调用 默认一帧就是一个渲染周期 Phaser.StateManager场景管理对象123var game = new Phaser.Game();game.state.add(name, state); //添加场景（场景名称，场景对象）game.state.start(name); //运行启动场景 Phaser.Loader 加载游戏资源12345678game.load.image(); //加载图片game.load.spritesheet(); //加载图片集 需小图尺寸一致game.load.atlas(); //加载图片集 大小不同 尺寸不一game.load.audio(); //加载声音game.load.audiosprite(); //加载声音集game.load.text(); //加载文本文件game.load.xml(); //加载XML文件game.load.binary(); //加载二进制文件 Loader事件 单个资源加载完成事件123game.load.onFileComlete.add(function()&#123; //单个资源加载成功后调用该事件 var progress =game.load.progress;//使用game.load.progress 来获取所有资源的加载进度1表示1%&#125;); 所有资源加载完成事件12game.load.onLoadComplete.add(function()&#123;&#125;); Phaser.Stage舞台1234var game = new Phaser.Game();//使用game.stage来引用舞台对象//改变舞台的背景颜色 十六进制颜色0xffffff 舞台默认黑色game.stage.setBackgroundColor(backgroundColor); Phaser.World 世界12//设置世界边界的大小game.world.setBounds(x, y, width, heigint); Phaser.Camera12345678game.camera.x = 100; //改变摄像机在X轴上的位置game.camera.y = 100; //改变摄像机在Y轴上的位置game.camera.focusOn(displayObject); //让摄像机定位到物体上game.camera.focusOnxy(x, y); //让摄像机定位到x, y这个坐标上game.camera.follow(target); //让摄像机跟随目标物体targetsprite.fixedToCamera = true;//精灵固定到摄像机sprite.cameraOffset.setTo(200, 500);//相对于摄像机的偏移 游戏的缩放控制123//可以使用game.scale 来引用当前游戏的Phaser.ScaleManager对象//之后可以使用 scaleMode 属性来改变缩放模式game.scale.scaleMode = Phaser.ScaleManager.EXACT_FIT; 缩放模式 EXACT_FIT 缩放到父元素的大小，可能会改变宽高比 SHOW_ALL 保持宽高比缩放到父元素的大小 一般用这个 USER_SCALE 自定义缩放 需要使用 game.scale.setUserScale(0.5, 0.5) 设定 缩放配置可以放到init方法中 水平和垂直居中12game.scale.pageAlignHorizontally = true; //水平居中game.scale.pageAlignVertically = true; //垂直居中 文字1game.add.text(x, y, text, style, group); style文字样式设置的3种方法123456789var text = game.add.text(0, 0, &quot;Hello&quot;, Style); //添加文字时以对象的方式设置 可以直接设置或引用设置Style =&#123; font: &quot;bold 24px Arial&quot;, fill: &quot;#fff&quot;&#125;text.style.fill = &quot;#fff&quot;; //通过文字的styel对象设置text.fill = &quot;#fff&quot;; //在文字对象上直接设置 文字样式属性123456789text.fill = &apos;#fff&apos;; //文字颜色text.font = &apos;微软雅黑&apos;; //字体text.fontSize = 60; //字号text.fontWeight = &apos;normal&apos;; //粗细 默认加粗text.style.backgroundColor = &apos;#0f0&apos;; //背景颜色 必须通过style对象设置text.stroke = &apos;#f00&apos;; //描边颜色text.strokeThickness = 10; //描边宽度text.wordWrap = true; //自动换行text.wordWrapWidth = 150; //超过设定宽度 自动换行 wordWrap必须为true 特殊字体3种特殊字体12345webFont //类似于css的用法 需要先激活（建立一个dom容器 设定该容器的字体为webFont即可激活），因为加载字体需要一定的时间，使用Phaser 时可用setTimeout延迟加载。BitmapText //图片文字 一般用这个RetroFont //同BitmapText BitmapText 文字制作工具 BMFont (Windows, free): http://www.angelcode.com/products/bmfont/ Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner Littera (Web-based, free): http://kvazars.com/littera/ Littera的使用 先点击左侧的FONT Select Font 选择一个本地字体进行上传 在上方Included glyphs 输入框中输入需要的所有文字 使用 Fill Stroke 等进行样式的编辑 在上方导出栏里设置导出格式为XML（默认）点击Export导出 BitmapText 的使用 preload方法中1game.load.bitmapFont(&apos;font&apos;, &apos;asset/font.png&apos;, &apos;asset/font.fnt&apos;); //&apos;定义资源名称&apos;, &apos;文字图片路径&apos;, &apos;文字图片配置文件&apos; create方法中1var text = game.add.bitmapText(0, 0, &apos;font&apos;, &apos;Hello&apos;, 30);//x坐标, y坐标, 资源名称, 文字内容, 文字大小 组Phaser.world 是最顶层的组 创建组 1var group = game.add.group(); 给组添加子元素的几种方法 创建图片或精灵时指定组 group.add(key) 方法直接添加 (资源名称) group.create(x, y, ‘key’, frame?, exists?) 方法创建子元素并添加进组 (x坐标, y坐标, 资源名称, 帧, 是否显示) 组的操作 1234group.alpha = 0.5; //透明度group.x = 100; //x坐标group.scale.set(0.5); //缩放... 动画 Phaser.Tween 补间动画 Phaser.Animation 逐帧动画 补间动画 创建补间动画 123456789101112var tween = game.add.tween(boject);tween.to(propertis, duration, ease, autoStart, delay, repeat, yoyo);//当前过渡到指定tween.from(propertis, duration, ease, autoStart, delay, repeat, yoyo);//指定过渡到当前propertis //状态属性集合 &#123;x:300, y:200&#125;duration //持续时间 毫秒ease //缓动函数 参照文档 docs/src_tween_TweenManager.js.html easeMap部分autoStart //是否自动开始delay //延迟repeat //重复次数 -1无限次yoyo //是否反向执行 补间动画操作方法 1234tween.start(); //开始tween.stop(); //停止tween.pause(); //暂停tween.resume(); //恢复 使用方法 在create方法中 1234var phaser = game.add.image(0, 0, &apos;phaser&apos;);var tween = game.add.tween(phaser);tween.to(&#123;y:300&#125;, 2000, Phaser.Easing.Bounce.Out, true, 0, 100, true);tween.from(&#123;y:300&#125;, 2000, Phaser.Easing.Bounce.Out, true, 0, 100, true); 逐帧动画需要使用game.load.spritesheet 加载雪碧精灵图片且每个精灵大小相同 12345678910var sprite = game.add.sprite();//定义动画sprite.animations.add(name, frames);//播放动画sprite.animations.play(name, frameRate, loop, killOnComplete);//停止动画sprite.animations.stop(name); 123456789//preload方法中game.load.spritesheet(&apos;man&apos;, &apos;asset/man.png&apos;, 136, 152); //(&apos;key&apos;, &apos;资源路径&apos;, 每帧宽度, 每帧高度)//create方法中var man = game.add.sprite(0, 0, &apos;man&apos;);man.animations.add(&apos;run&apos;, [26,27,28,29,30]);//(&apos;定义动画名称&apos;, 动画所需的帧)man.animations.play(&apos;run&apos;, 60, true);//(&apos;要播放的动画名称&apos;, 每秒帧数, 是否循环) AtlasAtlas每一帧大小可以不固定 使用 http://renderhjs.net/shoebox/ 将图片拖到程序的Sprite Sheet上，生成XML格式的文件 1234//preload方法中game.load.atlasXML(&apos;man&apos;, &apos;asset/atlas.png&apos;, &apos;asset/atlas.xml&apos;);// (key, 图片资源地址, xml文件地址)//create方法同spritesheet动画 其中帧可以使用xml中帧的name值 粒子系统 粒子发射器的创建 1var emitter = game.add.emitter(x?, y?, maxParticles?); //(x坐标, y坐标, 粒子在屏幕上显示的最大数量) 创建粒子 1emitter.makeParticles(keys, frames?, quantity?, collide?, collideWorldBounds?);//(名称, 帧数, 要产生多少粒子, 粒子之间/粒子跟边界是否碰撞) 实例 1234567891011121314151617181920212223242526272829//preloadgame.load.image(&apos;bubble&apos;, &apos;asset/bubble.png&apos;);//create//粒子发射器的创建var emitter = game.add.emitter(game.width/2, game.height/2, 50);//(x坐标, y坐标, 粒子在屏幕上显示的最大数量)//创建粒子emitter.makeParticles(&apos;bubble&apos;, [0,1,2,3,4,5,6,7], 1000, true, true);//(名称, 可用帧（随机调用）, 要产生多少粒子, 粒子之间/粒子跟边界是否碰撞)//粒子的控制emitter.setXSpeed(500, 1000);//X轴控制速度(min?, max?) 负值先左正值向右emitter.setXSpeed(500, 1000);//Y轴控制速度(min?, max?)emitter.setScale(0, 1, 0, 1, 3000);//缩放 (minX?, maxX?, minY?, maxY?, rate?) rate：最小值过渡到最大值的时间emitter.setAlpha(0, 1, 3000);//透明度 (min?, max?, rate?, ease?)emitter.setRotation(100, 200); //角速度,自身旋转的速度 (min?, max?)//物理引擎emitter.gravity = 600; //重力emitter.bounce.y = 0.8; //弹跳//发射粒子emitter.start(false, 3000, 1000, 50);//(是否一次发射所有粒子如为false则一次发射一个, 粒子生存时间, 多久发射一次, 有多少粒子需要发射默认50 )//发射粒子方法2 可无限发射emitter.flow(3000, 1000, 10, -1); //(粒子生存周期0为永远不会消失, 多久发射一次, 每一次发射多少粒子, 总共有多少粒子可以发射-1位无限)//updategame.physice.arcade.collide(emitter); //每一帧进行碰撞检测 Tiled 瓦片地图 制作工具 http://www.mapeditor.org/ 添加瓦片图集 新建图层 设置图块大小 构建地图 可使用图章和油漆桶工具，填充错误可使用橡皮擦工具，按ctrl可连续选中图集 导出地图 选择json 使用tiled 瓦片地图12345678910//preloadgame.load.tilemap(&apos;mario_map&apos;, &apos;asset/tilemap/mario.json&apos;, null, Phaser.Tilemap.TILED_JSON);//(资源名称, 资源json地址, null, 格式)game.load.image(&apos;mario&apos;, &apos;asset/tilemap/mario.png&apos;);//加载瓦片图片集合//createvar map = game.add.tilemap(&apos;mario_map&apos;); //(资源名称) 创建瓦片地图map.addTilesetImage(&apos;super_mario&apos;, &apos;mario&apos;); //添加瓦片地图集合(Tiled软件中瓦片集合名称, 瓦片集合图片资源名称) var layer = map.createLayer(&apos;world&apos;); //创建层 (Tiled软件中层的名字) 动态修改瓦片地图 123456789101112131415//create//注意，所有参数已瓦片为单位不是像素，从0开始//获取指定位置上的瓦片 var tile = map.getTile(0, 24);//在指定位置设置指定的瓦片map.putTile(tile, 0, 0);//在指定区域填充指定的瓦片 （瓦片集合索引，开始位置x,y, 结束位置x,y）map.fill(12, 0, 0, 20, 20);//瓦片的复制与粘贴var tiles = map.copy(0, 19, 5, 5);map.paste(0, 0, tiles);//在指定区域内用一种瓦片替换另一种瓦片 前两个参数为集合索引，后四个为矩形区域，不指定区域替换所有map.replace(1, 12, 0, 0, 10, 10); 瓦片地图碰撞检测 123tilemap.setCollision(indexes, collides?, layer?); //(可以是一个数组瓦片集合索引, 是否进行碰撞检测, 在哪个层进行碰撞检测)tilemap.setCollisionBetween(start, stop, collides?, layer?);//(瓦片集合索引开始, 瓦片集合索引结束, 是否进行碰撞检测, 在哪个层进行碰撞检测) 实例 123456789101112131415161718192021//create//设置需要碰撞的瓦片map.setCollisionBetween(15,16);map.setCollisionBetween(20,25);map.setCollision(40);//设置要碰撞的瓦片从1开始map.setCollision([20,21,26,27,15,23,38, 39,40]);//排除要碰撞的瓦片map.setCollisionByExclusion([7, 32, 35, 36, 47]);//针对gameLayer这个层进行碰撞检测，即别的层不受影响map.setCollisionBetween(1, 40, true, gameLayer);//启用物理引擎game.physics.startSystem(Phaser.physics.ARCADE);//updategame.physics.arcade.collide(player, layer);//碰撞检测//角色与地图图层接触后该方法返回trueplayer.body.onFloor() 事件系统Phaser.Signal Signal对象的创建 12345678910111213141516171819var signal = new Phaser.Signal();//添加事件监听器signal.add(listener, listenerContext?, priority?, args?, args?, args?....);//(函数, 函数上下文, 优先度, 参数可以有多个)//添加事件监听器 只执行一次signal.addOnce(listener, listenerContext?, priority?, args?, args?, args?....);//移除单个事件监听器signal.remove(listener);//移除该signal对象上的所有事件监听器signal.removeAll();//向所有该signal对象上的监听器分发事件signal.dispatch(params?);//注销signal对象 注销后不会再分发事件 相应内存也会被释放signal.dispose(); 一些重要的系统事件 1234567891011121314151617181920212223242526272829303132333435var game = new Phaser.Game();//onBlur, onFocus, onPause, onResume 都是game对象的一个属性，但代表的都是一个signal对象game.onBlur //游戏失去焦点game.onFocus //游戏获得焦点game.onPause //游戏暂停事件game.onResume //游戏恢复事件//给onPause添加一个事件监听器game.onPause.add(function()&#123; alert(&apos;游戏已暂停&apos;);&#125;)//scale对象game.scale.onFullScreenChange //当进入或退出全屏时game.scale.onOrientationChange //当设备横竖屏切换时game.scale.onSizeChange //当游戏尺寸改变时//资源加载中的一些事件game.load.onFileComplete //当一个文件加载完成时game.load.onFileError //当一个文件加载失败时game.load.onFileStart //当一个文件开始加载时game.load.onLoadComplete //当所有资源加载完成时//补间动画中的一些事件tween.onStarttween.onCompletetween.onLooptween.onRepeat//关键帧动画事件animation.onStartanimation.onCompleteanimation.onLoopanimation.onUpdate //动画帧变化时 用户交互管理对象 Phaser.Input1234var game = new Phaser.Game();//使用游戏实例对象的input属性来引用当前的用户交互管理对象game.input // =&gt; new Phaser.Input(game) 基本属性和方法 1234567891011game.input.onDown //按下事件game.input.onUp //离开事件game.input.onTap //轻击事件game.input.onHold //长按事件//添加鼠标或手指移动事件侦听器game.input.addMoveCallback(callback, context);//删除鼠标或手指移动事件侦听器game.input.deleteMoveCallback(callback, context); Pointer对象 代表一个指针对象，可以是鼠标，手指或其他输入设备。多点触摸会出现多个Pointer对象 12345678910var game = new Phaser.Game();//获取最近一次激活的pointer对象var pointer = game.input.activePointer;pointer.clientX //指针事件发生时的x坐标pointer.clientY //指针事件发生时的Y坐标pointer.isDown //用来判断指针是否在按下状态pointer.isUp //用来判断指针是否在释放状态 鼠标对象 1234567891011121314//获取鼠标对象var mouse = game.input.mouse;//获取为鼠标定制的Pointer对象var mousePointer = game.input.mousePointer//设置鼠标滚轮事件的回调函数mouse.mouseWheelCallback//鼠标滚轮的滚动方向，1为向上， -1为向下mouse.wheelDeltamousePointer.leftButton //鼠标左键对象mousePointer.middleButton //鼠标中键对象mousePointer.rightButton //鼠标右键对象 键盘对象 1234567891011121314151617181920var game = new Phaser.Game();//获取键盘对象var keyboard = game.input.keyboard;//添加按键回调 所有按键keyboard.addCallbacks(context, onDown, onUp, onPress)//创建一个键对象var key = keyboard.addKey(keycode) //=&gt;返回Phaser.Key对象 keycode文档中查找//创建一个包含上下左右方向键的对象keyboard.createCursorKeys()key.isDown //用来判断该键是否处于按下状态key.isUp //用来判断该键是否处于释放状态key.onDown //键按下时的Signal对象key.onUp //键释放时的Signal对象key.altKey //判断是否alt键也被同时按下key.ctrlKey //判断是否ctrl键也被同时按下key.shiftKey //判断是否shift键也被同时按下 实例 - 画笔 12345678910111213141516171819this.create = function()&#123; graphics = game.add.graphics(0, 0); //创建图形对象 game.input.onDown.add(function()&#123;//指针按下时 graphics.beginFill(0xffffff);//设置填充样式 draw(); game.input.addMoveCallback(draw);//添加指针移动回调函数 &#125;); game.input.onUp.add(function()&#123; game.input.deleteMoveCallback(draw); //删除指针移动回调函数 &#125;);&#125;function draw()&#123; var pointer = game.input.activePointer; graphics.drawCircle(pointer.x, pointer.y, 10); //绘制直径为10的圆&#125; 实例 - 键盘 123456789101112131415var rightKey;this.create = function()&#123; //添加按键 rightKey = game.input.keyboard.addKey(Phaser.Keyboard.RIGHT);//右方向键 其他常量 UP DOWN LEFT&#125;this.update = function()&#123; if(upKey.isDown)&#123; sprite.y--; &#125;else if(otherKey.isDown)&#123; otherCode; &#125;&#125; 特定游戏对象的交互事件处理 Phaser.Eventsinput的为全局 events为特定对象 12345678910var game = new Phaser.Game();var sprite = game.add.sprite();sprite.inputEnabled = true; //开启输入事件//获取该游戏对象的Phaser.Events对象var events = sprite.events;events.onInputDown; //当指针在该对象上按下时的事件（signal）events.onInputUp; //当指针在该对象上释放时的事件（signal）events.onInputOver; //当指针进入该对象时的事件（signal）events.onInputOut; //当指针离开该对象时的事件（signal） Phaser.InputHandler对象 拖动对象 1234567891011121314151617var game = new Phaser.Game();var sprite = game.add.sprite();sprite.inputEnabled = true; //开启输入事件//获取该游戏对象的Phaser.InputHandler对象var InputHandler = sprite.input;inputHandler.enableDrag() //使对象能拖动inputHandler.disableDrag() //禁用拖动inputHandler.pointerOver() //判断指针是否在该对象之内inputHandler.pointerOut() //判断指针是否在该对象之外inputHandler.pointerX() //当指针在该对象之内时相对于该对象的X坐标inputHandler.pointerY() //当指针在该对象之内时相对于该对象的y坐标//当设置该值为true时,//在单击或拖动该对象时它会自动位于显示列表的最上方inputHandler.bringToTop 音频处理 Phaser.SoundManager123456var game = new Phaser.Game();var soundManager = game.sound; //获取SoundManager对象//game.add.audio()方法返回的就是一个Phaser.Sound对象var sound = game.add.audio(key, volume?, loop?); //(资源名称, 音量大小0~1, 是否循环) 音频资源的加载 12345game.load.audio(key, urls, autoDecode?); //(资源名称, 资源地址, 是否自动解码(true));game.load.audio(&apos;foo&apos;, &apos;foo.mp3&apos;); //字符串形式game.load.audio(&apos;foo&apos;, [&apos;foo.ogg&apos;, &apos;foo.wav&apos;, &apos;foo.mp3&apos;]); //数组形式 audio sprite 1game.load.sudiosprite(key, urls, jsonURL?, jsonDate?, autoDecode?);// jsonUrl,jsonDate 二选一 audio sprite 数据生成工具https://github.com/tonistiigi/audiosprite --autoplay bg_loop --output mygameaudio bg_loop.wav *.mp3```12&gt; 实例 \\preload \\单一音频game.load.audio(‘sound1’, ‘asset/audio/1.mp3’); \\音频spritegame.load.audiosprite(‘audiosprite’, [ ‘asset/audio/maudiosprite.ogg’, ‘asset/audio/maudiosprite.m4a’, ‘asset/audio/maudiosprite.mp3’, ‘asset/audio/maudiosprite.ac3’], ‘asset/audio/maudiosprite.json’,); \\createvar sound = game.add.audio(‘sound1’);var audiosprite = game.add.audioSprite(‘audiosprite’);1234## 音频资源的使用和管理&gt; 播放控制 sound.play(marker?, position?, volume?, loop?, forceRestart?);//marker 标注名称//position 播放位置//volume 音量 0~1//loop 是否循环//forceRestart 是否强制重新开始 sound.pause(); //暂停播放sound.resume(); //恢复播放sound.stop(); //停止播放 12&gt; 分段标注 //标注声音sound.addMarker(name, start, duration, volume?, loop?);//name 资源名称//start 开始时间 秒//duration 持续时间 秒//volume 音量大小//loop 循环 sound.play(name); //播放标注的声音 sound.removeMarker(name); //移除标注12&gt; 声音的淡入淡出 //淡入sound.fadeIn(duration?, loop?, marker?);//duration 持续时间 毫秒//替代sound.play //淡出sound.fadeOut(duration?);//自定义sound.fadeTo(duration?, volume?);volume 过渡到的音量12&gt; 声音事件相关的Signal对象 sound.onPlaysound.onPausesound.onResumesound.onStopsound.onFadeComplete //淡入淡出完成时sound.onMarkerComplete //某一段标注的声音播放完成时sound.onLoopsound.onMute //静音时1ex sound.onPlay.add(function(){ alert(‘Play’);})1234## 物理引擎&gt; 开启物理引擎 \\Phaser默认使用ARCADE物理引擎，所以可以不写下面这句game.physics.startSystem(Phaser.Physics.ARCADE);12&gt; 在游戏精灵上启用物理引擎 game.physics.enable(sprite, Phaser.Physics.ARCADE);1234&gt; 在组中启用物理引起为组中的没一个子元素启用物理引擎 group.enableBody = true; //指定物理引擎group.physicsBodyType = Phaser.Physics.AARCADE;1234&gt; 精灵的body对象当精灵启用物理引擎后，就会拥有一个body属性，物理属性都是附加在精灵的body对象上的。 sprite.body;1234&gt; body属性速度 sprite.body.velocity = new Phaser.Point(100, 100); //(x, y) x为横向运动，正值向右，负值向左 //ORsprite.body.velocity.set(100); //(x,y)如果只传一个参数，说明x和y都是这个值 //ORsprite.body.velocity.x = 100;sprite.body.velocity.y = 100;1加速度 sprite.body.acceleration = new Phaser.Point(100, 100); //ORsprite.body.acceleration.set(100); //ORsprite.body.acceleration.x = 100;sprite.body.acceleration.y = 100;12角速度和角速度的加速度 sprite.body.angularVelocity = 90; //正数顺时针旋转，负数为逆时针旋转 单位：度/秒 sprite.body.angularAcceleration = 45;12阻力 sprite.body.drap = new Phaser.Point(100, 100); //ORsprite.body.drap.set(100); //ORsprite.body.drap.x = 100;sprite.body.drap.y = 100; 12重力 sprite.body.gravity = new Phaser.Point(100, 100); //ORsprite.body.gravity.set(100); //ORsprite.body.gravity.x = 100;sprite.body.gravity.y = 100;12弹跳 0~1 sprite.body.bounce = new Phaser.Point(0.5, 0.5); //ORsprite.body.bounce.set(0.5); //ORsprite.body.bounce.x = 0.5;sprite.body.bounce.y = 0.5; 12OTHER sprite.body.friction.set(100); //设置与其他物体接触时的摩擦力sprite.body.rotation = Math.PI; //设置角度sprite.body.immovable = true; //设置该物体是否时固定的sprite.body.mass = 10; //设置物体的相对质量, 默认为1sprite.body.maxVelocity.set(100, 200); //设置最大速度sprite.maxAngular = 1000; //设置最大角速度 sprite.body.setSize(width, height, offsetX, offsetY); //设置body范围大小sprite.body.reset(x, y);//重置所有物理属性 123#### Arcade引擎提供的一些静态方法以指定的速度运动到目的地(返回到目的地的角度) game.physics.arcade.moveToXY(sprite, x, y, speed);game.physics.arcade.moveToObject(sprite, destination, speed);game.physics.arcade.moveToPointer(sprite, speed, potinter);12以指定的加速度运动到目的地 game.physics.arcade.accelerateToXY(sprite, x, y, speed);game.physics.arcade.accelerateToObject(sprite, destination, speed);game.physics.arcade.accelerateToPointer(sprite, speed, potinter);12一些工具 //计算角度game.physics.arcade.angleBetween(source, target);game.physics.arcade.angleToPointer(displayObject, pointer);game.physics.arcade.angleToXY(displayObject, x, y); //计算距离game.physics.arcade.distanceBetween(source, target);game.physics.arcade.distanceToPointer(displayObject, pointer);//计算速度game.physics.arcade.1234## 碰撞检测overlap方法 只是检测不产生物理效果 需使用在update方法中 game.physics.arcade.overlap(sprite1, sprite2, function(){console.log(‘It is overlap!’)});1collide方法 产生物理效果 需使用在update方法中，对象可以是精灵或组 game.physics.arcade.collide(sprite1, sprite2, function(){console.log(‘It is collide!’)}); game.physics.arcade.collide(sprite, group); game.physics.arcade.collide(group); //组内碰撞检测1与游戏边界进行碰撞检测 sprite.body.collideWorldBounds = true;123## debug显示FPS //preloadgame.time.advancedTiming = true; //rendergame.debug.text(game.time.fps, 32, 320, “#00ff00”);`","categories":[],"tags":[{"name":"phaser","slug":"phaser","permalink":"http://bigma.cc/tags/phaser/"}]},{"title":"MongoDB学习手记","slug":"MongoDB学习手记","date":"2017-05-18T14:27:26.000Z","updated":"2023-09-06T14:03:24.660Z","comments":true,"path":"2017/05/18/MongoDB学习手记/","link":"","permalink":"http://bigma.cc/2017/05/18/MongoDB学习手记/","excerpt":"","text":"下载 http://www.mongodb.org/downloads 建立数据目录1D:\\data\\db 运行cmd 进入mongoDB的bin目录1mongod.exe --dbpath d:\\data\\db 作为windows服务运行管理员权限运行123456789mongod.exe --bind_ip yourIPadress #绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP--logpath \"D:\\data\\dbConf\\mongodb.log\" #定MongoDB日志文件，注意是指定文件不是目录--logappend #使用追加的方式写日志--dbpath \"D:\\data\\db\" #指定数据库路径--port yourPortNumber # 指定服务端口号，默认端口27017--serviceName \"YourServiceName\" #指定服务名称--serviceDisplayName \"YourServiceName\" #指定服务名称，有多个mongodb服务时执行。--install #指定作为一个Windows服务安装。 MongoDB Shellbin目录下的mongo.exe 1234&gt; mongoMongoDB shell version: 3.0.6connecting to: test…… db命令用于查看当前操作的数据库 连接数据库使用用户名fred，密码foobar登录localhost的baz数据库。 mongodb://fred:foobar@localhost/baz 创建数据库/切换数据库 use DATABASE_NAME 删除当期数据库 db.dropDatabase() 插入文档col为集合12345db.col.insert(&#123;title: &apos;MongoDB 教程&apos;, description: &apos;MongoDB 是一个 Nosql 数据库&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 100&#125;) 可将数据定义为一个变量。 更新 db.col.update({‘title’:’MongoDB 教程’},{$set:{‘title’:’MongoDB’}}, upsert, multi) {‘title’:’MongoDB 教程’} 为查询条件 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 删除1234567db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) query :（可选）删除的文档的条件。justOne : （可选）如果设为 true 或 1，则只删除一个文档。writeConcern :（可选）抛出异常的级别。 删除所有数据 db.col.remove({}) 查询查询所有 db.col.find().pretty() 条件 db.col.find({“by”:”菜鸟教程”, “title”:”MongoDB 教程”}).pretty() 条件操作符1234(&gt;) 大于 - $gt(&lt;) 小于 - $lt(&gt;=) 大于等于 - $gte(&lt;= ) 小于等于 - $lte likes 大于100的数据 db.col.find({“likes” : {$gt : 100}}) $type 操作符 类型 数字 Double 1 String 2 Object 3 Array 4 Binary data 5","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://bigma.cc/tags/mongodb/"}]},{"title":"Angular2学习手记","slug":"Angular2学习手记","date":"2017-03-08T15:23:15.000Z","updated":"2023-09-06T14:03:24.659Z","comments":true,"path":"2017/03/08/Angular2学习手记/","link":"","permalink":"http://bigma.cc/2017/03/08/Angular2学习手记/","excerpt":"","text":"安装angular-cli1npm install -g @angular/cli 创建工程1ng new project 启动项目1ng serve 打开浏览器访问 http://localhost:4200/ app works!自动创建了一个模块 项目名称/src/app 修改app.component.ts中的title可自动编译 创建模块123ng generate component User#简化ng g c user 目录说明app/app.component.*根组件 assets/*图片等资源 styles.css全局样式 压缩/预编译1ng serve --prod --aot 编译1ng build --prod --aot 自动化测试12# 可参照Angularjs1.0版本ng test 模版语法123&lt;script&gt; 是无效的&lt;html&gt;&lt;body&gt;&lt;base&gt;也没有意义插值 &#123;&#123;&#125;&#125; NG2 组件关系 组件数据传递","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://bigma.cc/tags/前端/"},{"name":"Angular","slug":"Angular","permalink":"http://bigma.cc/tags/Angular/"}]},{"title":"nodejs学习手记","slug":"nodejs学习手记","date":"2017-02-14T14:26:34.000Z","updated":"2023-09-06T14:03:24.663Z","comments":true,"path":"2017/02/14/nodejs学习手记/","link":"","permalink":"http://bigma.cc/2017/02/14/nodejs学习手记/","excerpt":"","text":"LINUX安装node从官网下载linux已编译版本 https://nodejs.org/en/download/ wget https://nodejs.org/dist/v6.9.5/node-v6.9.5-linux-x64.tar.xz 解压 tar xvf node-v6.9.5-linux-64 设置全局连接12ln -s /root/node-v6.9.5-linux-x64/bin/node /usr/local/bin/nodeln -s /root/node-v6.9.5-linux-x64/bin/npm /usr/local/bin/npm 1.创建一个http服务器123456789101112var http = require('http');http.createServer(function (request, response) &#123;// 发送 HTTP 头部// HTTP 状态值: 200 : OK// 内容类型: text/plainresponse.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;);// 发送响应数据 \"Hello World\"response.end('Hello World\\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如 本地安装 npm install express 全局安装 npm install express -g 你可以使用以下命令来查看所有全局安装的模块： $ npm ls -g 1234567891011Package.json 属性说明name - 包名。version - 包的版本号。description - 包的描述。homepage - 包的官网 url 。author - 包的作者姓名。contributors - 包的其他贡献者姓名。dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require(&quot;express&quot;)。keywords - 关键字 卸载模块我们可以使用以下命令来卸载 Node.js 模块。 $ npm uninstall express 卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看： $ npm ls 更新模块我们可以使用以下命令更新模块： $ npm update express 搜索模块使用以下来搜索模块： $ npm search express 创建模块 NPM init #REPL 我们可以输入以下命令来启动 Node 的终端：12$ node&gt; 这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。 普通计算 3+8 代数计算 var x=10; x+10 do…while循环_可获取表达式的值123x+yvar sum = _sum可输出x+y的值 REPL 命令12345678910ctrl + c - 退出当前终端。ctrl + c 按下两次 - 退出 Node REPL。ctrl + d - 退出 Node REPL.向上/向下 键 - 查看输入的历史命令tab 键 - 列出当前命令.help - 列出使用命令.break - 退出多行表达式.clear - 退出多行表达式.save filename - 保存当前的 Node REPL 会话到指定文件.load filename - 载入当前 Node REPL 会话的文件内容。 回调函数","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://bigma.cc/tags/nodejs/"}]},{"title":"实验室","slug":"实验室","date":"0999-12-31T16:04:10.000Z","updated":"2023-09-06T14:03:24.665Z","comments":true,"path":"1000/01/01/实验室/","link":"","permalink":"http://bigma.cc/1000/01/01/实验室/","excerpt":"前端实验项目","text":"前端实验项目 兔子白噪音-微信小程序白噪音是一种让人能专注工作和学习，或安然入眠的一种声音。可通过微信搜索”兔子白噪音体验“，或扫描下方小程序码 特色：极少的按钮，只有加减时间和播放按钮，通过滑动切换音效，最快实现使用，没有花里花哨的功能，3秒操作完成，减少打断时间。锁屏后也可正常播放。 超级玛丽H5小游戏-Phaser使用 Phaser 开发的一款小游戏，使用了物理引擎，瓦片地图，序列动画。 可扫码体验 捡钱小游戏-Egret使用 Egret Lakeshore 开发的小游戏，因为当初做的时候这款工具处于内测阶段所以有效音效有些问题。","categories":[],"tags":[]}]}